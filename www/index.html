<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <!-- This is a wide open CSP declaration. To lock this down for production, see below. -->
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline'; style-src 'self' 'unsafe-inline'; media-src *" />
    <!-- Good default declaration:
    * gap: is required only on iOS (when using UIWebView) and is needed for JS->native communication
    * https://ssl.gstatic.com is required only on Android and is needed for TalkBack to function properly
    * Disables use of eval() and inline scripts in order to mitigate risk of XSS vulnerabilities. To change this:
        * Enable inline JS: add 'unsafe-inline' to default-src
        * Enable eval(): add 'unsafe-eval' to default-src
    * Create your own at http://cspisawesome.com
    -->
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: 'unsafe-inline' https://ssl.gstatic.com; style-src 'self' 'unsafe-inline'; media-src *" /> -->

    <!--
	<link rel="stylesheet" type="text/css" href="css/index.css" />
    -->
	
	<title>Panic Train</title>
	
	<style type="text/css"> 
		
		/*trying something out for responsive web design, as with the meta tag above*/
		@-ms-viewport
		{
		  width: device-width;
		}
		
		@font-face {
		font-family: "ineptic";
		src: url(font/font_ineptic.otf) format("truetype");
		}
		
		@font-face {
		font-family: "lindenhill";
		src: url(font/font_lindenhill.otf) format("truetype");
		}
		
		@font-face {
		font-family: "lindenhill_italic";
		src: url(font/font_lindenhill_italic.otf) format("truetype");
		}
				
		@font-face {
		font-family: "steamwreck";
		src: url(font/font_steamwreck.otf) format("truetype");
		}
		
		html 
		{
		  /*cursor: url('images/pointer.png'), auto;	*/
		}
		
		body 
		{
			color: #E9E9E9;
			background-color: black;	
			font-family: "My Custom Font", Robota, Tahoma;
			font-size: 15px;
			background-image: url("images/metal.png");
		}
	
		.button2 
		{
			color: black;
			background-color: darkgrey;
			border: 1px solid darkgrey;
			padding: 2px 4px;
			text-align: center;
			text-decoration: none;
			display: inline-block;
			font-size: 18px;
			font-family: 'Abel', sans-serif;
			margin: 4px 2px;
			-webkit-transition-duration: 0.4s; /* Safari */
			transition-duration: 0.4s;
			cursor: pointer;
			height: 40px;
			width: 50px; /*50px*/
			border-radius: 4px;
		}
		
		.button2:hover 
		{
			color: black;
			background-color: orange;			
			border: 1px solid black;
		}
		
		.button3 
		{
			color: black;
			background-color: grey;
			border: 1px solid black;
			padding: 2px 4px;
			text-align: center;
			text-decoration: none;
			display: inline-block;
			font-size: 22px;
			font-family: 'lindenhill_italic', sans-serif;
			margin: 4px 2px;
			-webkit-transition-duration: 0.4s; /* Safari */
			transition-duration: 0.4s;
			cursor: pointer;
			height: 40px;
			width: 50px; /*50px*/
			border-radius: 4px;
		}
		
		.button3:hover 
		{
			color: black;
			background-color: lightgrey;			
			border: 1px solid black;
		}
		
		.primaryCanvas 
		{
			display:none;
			/*cursor: url('images/arrow3.png'), auto;*/	
			/*background:#0e8e39;*/ 
			position:absolute;
			top:10px; /*10px*/
			left: 10px; /*10px*/
			border: 0px solid rgba(0,255,0,.2);
			border: 1px solid rgba(0,0,0,1);
			border-radius: 12px;
			z-index:2;
			/*background-image: radial-gradient(limegreen, darkgreen);*/ /*weird gradient bg*/
		}
				
		.titleText{
            color: peru;
            font-size: 80px; /*40*/
			font-family: "steamwreck", Verdana, Tahoma; /*ineptic lindenhill*/ 
        } 
		
		.storyTitle{
            color: peru;
            font-size: 40px; /*40*/
			font-family: "lindenhill", Verdana, Tahoma; /*ineptic lindenhill*/ 
        }
		
		.fancy
		{
			color: white;
            font-size: 20px;
			font-family: "lindenhill_italic", Verdana, Tahoma; /*ineptic*/
		}
		
		.center
		{
			text-align:center;
			-webkit-border-radius: 0.75em;
			/*-moz-border-radius: 0.75em;*/
			border-radius:0.75em;			
			/*background-color:rgba(33, 33, 33, 0.6);*/
			color:#ffffff;
			padding:25px;
			
			margin: 0;
			position: absolute;
			top: 40%;
			left: 50%;
			transform: translate(-50%, -30%);
	
		}
				
		.menuScreen
		{
			position: absolute;
			z-index:9;
			background:#232323;
			border: 2px solid black;
			display: block;
			width: 250px; /**/
			/*height:800px;*/
			display: none;
			background-image: url("images/metal2.png");
		}
		
		.storyScreen
		{
			display:none;
			/*
			position: absolute;
			z-index:9;
			background:black;
			
			border: 2px solid black;
			display: block;
			
			width: 240px; 
			height:430px;
			display: none;
			
			background-image: url("images/story2.png");
			*/
		}
		
		.storyText
		{
			text-align:left;
			position: absolute;
			top: 130px;
			left: 58px;
			width:223px;
			color: black;
            font-size: 20px;
			font-family: "lindenhill_italic", Verdana, Tahoma; /*ineptic*/
			
						
		}
		
		.noSelect
		{
			-webkit-user-select: none;  /* Chrome all / Safari all */
			-moz-user-select: none;     /* Firefox all */
			-ms-user-select: none;      /* IE 10+ */
			user-select: none;          /* Likely future */   
		}
		
		.menuImg
		{
			border: 2px solid black;
			width:240px;
		}
		
		@keyframes rainbow-text 
		{
		  0% {
			color: #e87d7d;
		  }
		  2% {
			color: #e88a7d;
		  }
		  4% {
			color: #e8977d;
		  }
		  6% {
			color: #e8a47d;
		  }
		  8% {
			color: #e8b07d;
		  }
		  10% {
			color: #e8bd7d;
		  }
		  12% {
			color: #e8ca7d;
		  }
		  14% {
			color: #e8d77d;
		  }
		  16% {
			color: #e8e47d;
		  }
		  18% {
			color: #dfe87d;
		  }
		  20% {
			color: #d3e87d;
		  }
		  22% {
			color: #c6e87d;
		  }
		  24% {
			color: #b9e87d;
		  }
		  26% {
			color: #ace87d;
		  }
		  28% {
			color: #9fe87d;
		  }
		  30% {
			color: #92e87d;
		  }
		  32% {
			color: #86e87d;
		  }
		  34% {
			color: #7de881;
		  }
		  36% {
			color: #7de88e;
		  }
		  38% {
			color: #7de89b;
		  }
		  40% {
			color: #7de8a8;
		  }
		  42% {
			color: #7de8b5;
		  }
		  44% {
			color: #7de8c1;
		  }
		  46% {
			color: #7de8ce;
		  }
		  48% {
			color: #7de8db;
		  }
		  50% {
			color: #7de8e8;
		  }
		  52% {
			color: #7ddbe8;
		  }
		  54% {
			color: #7dcee8;
		  }
		  56% {
			color: #7dc1e8;
		  }
		  58% {
			color: #7db5e8;
		  }
		  60% {
			color: #7da8e8;
		  }
		  62% {
			color: #7d9be8;
		  }
		  64% {
			color: #7d8ee8;
		  }
		  66% {
			color: #7d81e8;
		  }
		  68% {
			color: #867de8;
		  }
		  70% {
			color: #927de8;
		  }
		  72% {
			color: #9f7de8;
		  }
		  74% {
			color: #ac7de8;
		  }
		  76% {
			color: #b97de8;
		  }
		  78% {
			color: #c67de8;
		  }
		  80% {
			color: #d37de8;
		  }
		  82% {
			color: #df7de8;
		  }
		  84% {
			color: #e87de4;
		  }
		  86% {
			color: #e87dd7;
		  }
		  88% {
			color: #e87dca;
		  }
		  90% {
			color: #e87dbd;
		  }
		  92% {
			color: #e87db0;
		  }
		  94% {
			color: #e87da4;
		  }
		  96% {
			color: #e87d97;
		  }
		  98% {
			color: #e87d8a;
		  }
		  100% {
			color: #e87d7d;
		  }
		}
		.rainbow-text 
		{
		  animation: rainbow-text 1s infinite;
		}
				
	</style>
	
</head>

<body onload="startingSetup();" onkeyup="return playerKeyUp(event);">
      
	<canvas id="primaryCanvas" class="primaryCanvas" onmousemove="playerMouseMove(event)" onclick="canvasClick(event)"></canvas>
	
	<div id="menuScreen" class="menuScreen noSelect center">
		<span id="menuTitle" class="titleText rainbow-text" style="color:orange">PANIC TRAIN</span>
		<br />
		<img width="250px" class="menuImg" src="images/TK/win.jpg">
		<br /><br />
		<span id="output" class="fancy">No stops. No brakes. Only death.</span> <br />
		<br />
		<input type ="button" value ="START" style="width:245px;" onclick="showStory();" class="button2"><br />
	</div>
	
	<div id="storyScreen" class="storyScreen noSelect center">
		<div id="storyText" class="storyText "></div>
		<span id="menuTitle" class="storyTitle " style="color:orange">Chapter One</span>
		<br />
		<img src="images/story2.png">
		<br />
		<input type ="button" value ="- CONTINUE -" style="width:250px;" onclick="continueText();" class="button3"><br />
	</div>
	
	<div id="loseScreen" class="menuScreen noSelect center">
		<span class="titleText" style="color:red">GAME OVER</span>
		<br />
		<img width="250px" class="menuImg" src="images/TK/fail.jpg"> 
		<br />
		<span id="output_fail" class="fancy">The train has ground to a halt.</span> <br />
		<br />
		<span id="score_fail">SCORE: 0</span> <br />
		<span id="level_fail">LEVEL: 0</span> <br />
		<br />
		<input type ="button" value ="RESTART" style="width:245px;" onclick="continueGame();" class="button2"><br />
	</div>
	
	<div id="winScreen" class="menuScreen noSelect center">
		<span class="titleText" id="titleText" style="color:orange">VICTORY</span>
		<br />
		<img width="250px" class="menuImg" src="images/TK/win.jpg">
		<br />
		<span id="output_win" class="fancy">Choo choo motherfuckers.</span> <br />
		<br />
		<span id="score_win">SCORE: 0</span> <br />
		<span id="level_win">LEVEL: 0</span> <br />
		<br />
		<input type ="button" value ="CONTINUE" style="width:245px;" onclick="continueGame();" class="button2"><br />
	</div>
	
    <script type="text/javascript" src="cordova.js"></script>
    <script type="text/javascript" src="js/index.js"></script>
    <script type="text/javascript">
        app.initialize();
    </script>
	
	<script>
	
	//-------------------------------------------
	//NOTES / TODO LIST
	//-------------------------------------------
	
	
	//cursor/explosion positions seem off 
	//rotate turret or whatever to touch taps 
	//change track shit back to a simple version 
	//limit track going off the screen 
	
	/////////KINDA DONE
	//try make a thing for thomas text 
	//make sure shit resets correctly 
	//new backgrounds/menu
	//rotate turret to mouseXY 
	
	/*
	pressing keys to lay tracks
	Concentric ring explosions [think shelling]
	Fans/zombies rushing the train
	upgrades
	perhaps we should scale mapWidth/height down to specific tileSize increments and cap it for html 
	*/
	
	//-------------------------------------------
	//OBJECT/CLASS DECLARATIONS
	//-------------------------------------------
	
	function tile(pForeground, pBackground, pHealth, pSolid)
	{
		this.f = pForeground;
		this.b = pBackground;
		//this.detected = "na";
		//this.health = pHealth;
		//this.solid = pSolid;
		//this.light = 1;;
		//this.charCol = "white";
		//this.frame = 0;
		//this.bgFrame = 0;
		//this.special = 0;
		this.x = 0; //this is the onscreen coords, not the array coords
		this.y = 0; //this is the onscreen coords, not the array coords
	}
		
	function heavenlyBody(pX,pY)
	{
		this.x = pX;
		this.y = pY;
		this.dx = 0;
		this.dy = 0;
		this.distance = distanceArray[Math.floor(Math.random() * distanceArray.length)];
		this.radius = Math.floor(Math.random() * 2)+1;
		
		if(Math.floor(Math.random() * 10)>9)
			this.radius = 3;
		
		//if(Math.floor(Math.random() * 10)>8)
		//	this.type = "customStar"
		//else 
		this.type = "star";
		this.colour = greyShades[Math.floor(Math.random() * greyShades.length)];
		
		if(Math.floor(Math.random() * 10)>7)
			this.colour = colorArray[Math.floor(Math.random() * colorArray.length)];
		
		var rX = Math.floor(Math.random() * 3000)-1500;
		
	}
	
	function entity(pX, pY, pType)
	{
		this.x = pX;
		this.y = pY;
		this.rot = 270;
		this.dx = 0;
		this.dy = 0;
		this.ax = 0;
		this.ay = 0;
		this.speed = 0; 
		this.maxSpeed = 2; 
		this.xSpeed = 6; 
		this.jumpPower = 8
		this.hasGravity = true;
		this.health = 1;
		this.energy = 10;
		
		this.direction = "up";
		
		this.targetX = 0;
		this.targetY = 0;
		
		this.radius = 32;
		
		this.accelerationPower = 0.05; //0.05 //0.2
		this.turningSpeed = 5;
		
		this.image = new Image();
		this.image.src = "images/ninja_0.png";
		this.frame = 1;
		this.frameMax = 6;
		
		this.team = "enemy";
		this.type = pType;
		
		//stuff just for the player
		this.wallSlide = false;
		this.jumpStage = 0;
		
		
		//stuff for monsters/projectiles
		this.moveTimer = 0;
		this.moveTimerMax = 3;
		this.direction = "left";
		
		this.specialTimer = 12;
		this.specialTimerMax = 12;
		
		this.weapon = "blaster";
		this.missiles = 0;
		
		this.sparkTimer = 20;
		this.energyRegenTimer = 0;
		this.energyRegenTimerMax = 10;
		
		if(this.type=="spy")
		{
			this.health = 1;
			this.maxSpeed = 0;
			this.image.src = "images/ninja_3.png";
		}		
		else if(this.type=="grunt") 
		{
			this.health = 1;
			this.maxSpeed = 2;
			this.image.src = "images/turtle_0.png";
		}
		else if(this.type=="slider") 
		{
			this.team = "enemy";
			this.image.src = "images/small/sab_1.png";
			this.accelerationPower = 1; //0.05 //0.2
			this.turningSpeed = 5;
			this.maxSpeed = 4;
			this.turningSpeed = 5;
			this.weapon = "particle";
		}
		else if(this.type=="fan") 
		{
			var r = Math.floor(Math.random() * 9)+1;
			this.health = 1;
			this.maxSpeed = 0.5//1; //2
			this.image.src = "images/fan"+r+".png";
		}
		else if(this.type=="trainFront") 
		{
			this.team = "player";
			this.image.src = "images/expTrainFront2.png";
			this.health = 5;
		}
		else if(this.type=="trainWood") 
		{
			this.team = "player";
			this.image.src = "images/expTrainWood.png";
			this.health = 5;
		}
		else if(this.type=="trainGoods") 
		{
			this.team = "player";
			this.image.src = "images/expTrainGoods.png";
			this.health = 5;
		}
		else if(this.type=="trainBack") 
		{
			this.team = "player";
			this.image.src = "images/expTrainBack2.png";
			this.health = 5;
		}
		
		this.maxHealth = this.health;
		this.maxEnergy = this.energy;
	
	}
	
	function explosion(pX,pY,t)
	{
		this.frame = 0;
		this.x = pX;
		this.y = pY;
		this.type = t;
		this.canvas = "primaryCanvas";
	}
	
	//-------------------------------------------
	//GLOBALS VARIABLES AND ARRAY DECLARATIONS
	//-------------------------------------------
	//a lof of this shit (and other shit)
	//can be found in startingSetup() and hello()
	
	tileSize = 32;
	
	bloodDecal = [];
	for (var i = 0; i < 30; i++)
	{
		bloodDecal[i] = new Image();
		bloodDecal[i].src = "images/blood_red"+i+".png";
	}
	
	//expAnim = [];
	//for (var i = 1; i < 7; i++)
	//{
	//	expAnim[i] = new Image();
	//	expAnim[i].src = "images/PNG/explosion-"+i+".png";
	//}
	
	panel = new Image();
	panel.src = "images/panel.png";
		
	trainTurret = new Image();
	trainTurret.src = "images/ninja_1.png"; //trainTurret
	
	expTrainFront = new Image();
	expTrainGoods = new Image();
	expTrainWood = new Image();
	expTrainBack = new Image();
	expTrainFront.src = "images/expTrainFront2.png";
	expTrainGoods.src = "images/expTrainGoods.png";
	expTrainWood.src = "images/expTrainWood.png";
	expTrainBack.src = "images/expTrainBack2.png";
	
	greenSquare = new Image();
	greenSquare.src = "images/green.png";
	
	
	playerLevel = 1;
	
	gameStarted = false;
	
	explosionSheet = new Image();
	explosionSheet.src = "images/explosion_total.png";
	
	soundOn = true;
	
	heartEmpty = new Image();
	heartEmpty.src = "images/heart_empty.png";
	heartFull = new Image();
	heartFull.src = "images/heart.png";
	
	ninja = new Image();
	ninja.src = "images/ninja_3.png";
	
	dirt = new Image();
	dirt.src = "images/dirt.png";
	
	dirtB = new Image();
	dirtB.src = "images/dirt1.png";
	
	dirtC = new Image();
	dirtC.src = "images/dirt2.png";
	
	stone = new Image();
	stone.src = "images/stone1.png";
	
	rail = new Image();
	rail.src = "images/rail.png";
	railH = new Image();
	railH.src = "images/rail_h.png";
	railBottomLeft = new Image;
	railBottomRight = new Image;
	railBottomLeft.src = "images/rail_bottomleft.png";
	railBottomRight.src = "images/rail_bottomright.png";
	railTopLeft = new Image;
	railTopRight = new Image;
	railTopLeft.src = "images/rail_topleft.png";
	railTopRight.src = "images/rail_topright.png";
	
	ship = [];
	
	touchText = "";
	
	//starScape = new Image();
	//starFog = new Image();
	//starScape.src = "images/newStars2.png";
	//starFog.src = "images/fog2.png"; // starFog
	
	star = [];
	
	greyShades = 
	[
	"#E0E0E0",
	"#D3D3D3",
	"#C0C0C0",
	"#B8B8B8",
	"#A9A9A9",
	"#A0A0A0",
	"#909090",
	"#696969",
	"#585858",
	"#484848",
	"#282828",
	//"yellow",
	//"darkgreen",
		//"dodgerblue",
		//"darkred"//,
	//"nebula"
	];
	
	var colorArray = ['#FF6633', '#FFB399', '#FF33FF', '#FFFF99', '#00B3E6', 
		'#E6B333', '#3366E6', '#999966', '#99FF99', '#B34D4D',
		'#80B300', '#809900', '#E6B3B3', '#6680B3', '#66991A', 
		'#FF99E6', '#CCFF1A', '#FF1A66', '#E6331A', '#33FFCC',
		'#66994D', '#B366CC', '#4D8000', '#B33300', '#CC80CC', 
		'#66664D', '#991AFF', '#E666FF', '#4DB3FF', '#1AB399',
		'#E666B3', '#33991A', '#CC9999', '#B3B31A', '#00E680', 
		'#4D8066', '#809980', '#E6FF80', '#1AFF33', '#999933',
		'#FF3380', '#CCCC00', '#66E64D', '#4D80CC', '#9900B3', 
		'#E64D66', '#4DB380', '#FF4D4D', '#99E6E6', '#6666FF'];
	
	distanceArray = [0.10,0.25,0.5,0.75,1,1.25];
	
	keyArray = 	[
					['Q','VK_Q'],
					['P','VK_P'],
					['E','VK_E'],
					['R','VK_R']
				];
	
	//-------------------------------------------
	//some general functions
	//-------------------------------------------
	
	//might not be a perfect test, but beautifully lightweight.
	function isMobileDevice() 
	{
		return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
	}
	
	//get distance between two sets of coords
	function getDist(x, y, x2, y2)
	{
		x = x2 - x;
		y = y2 - y;
		return Math.floor(Math.sqrt(x * x + y * y));
	}
	
	//simplified function for writing text that wraps to the canvas
	function wrapText(ctx, text, x, y, maxWidth, lineHeight) 
	{
		var words = text.split(' ');
        var line = '';

        for(var n = 0; n < words.length; n++) 
		{
			var testLine = line + words[n] + ' ';
			var metrics = ctx.measureText(testLine);
			var testWidth = metrics.width;
			if (testWidth > maxWidth && n > 0) 
			{
				ctx.fillText(line, x, y);
				line = words[n] + ' ';
				y += lineHeight;
			}
			else 
			{
				line = testLine;
			}
        }
        ctx.fillText(line, x, y);
    }
	
	//create an explosion (of a particular type) at xy coord
	function explodeSomething(x,y,type)
	{
		if(type=="spark")
		{
			var explosion_colors = ['#FFFF00','#FFD700'];
			var explosion = new ExplosionClass(x, y, explosion_colors,3); //3
		}
		else if(type=="ting")
		{
			var explosion_colors = ['blue','aqua','teal'];
			var explosion = new ExplosionClass(x, y, explosion_colors,4);
		}
		else
		{
			var explosion_colors = ['orange','red','FireBrick','darkorange'];
			var explosion = new ExplosionClass(x, y, explosion_colors,8);
		}
		
		explosion.ctx = context;
		explosions.push(explosion);
		
	}
		
	
	//-------------------------------------------
	//input handling: keyboard, mouse, touch
	//-------------------------------------------
	
	//called when the player releases a key on keyboard
	function playerKeyUp(e)
	{
		var keynum;

		if (window.event) // IE                    
		{
			keynum = e.keyCode;
		}
		else if (e.which) // Netscape/Firefox/Opera
		{
			keynum = e.which;
		}

		var keyPressed = "?";
		for(var name in ROT){
			if(ROT[name] == keynum && name.indexOf("VK_") == 0) {keyPressed=name;}
		}

		if(keyPressed=="VK_LEFT")
		{
			comp[0].direction="left";
		}
		else if(keyPressed=="VK_RIGHT")
		{
			comp[0].direction="right";
		}
		else if(keyPressed=="VK_UP")
		{
			comp[0].direction="up";
		}
		else if(keyPressed=="VK_DOWN")
		{
			comp[0].direction="down";
		}
		
		else if(keyPressed=="VK_F")
		{
			
		}
		
		else if(keyPressed==keyArray[0][1])
			layTrack(0)
		else if(keyPressed==keyArray[1][1])
			layTrack(1);
		
		//else if(keyPressed=="VK_Q")
		//{
		//	layTrack(1);
		//}
				
	}
		
	//event listener for moving a finger on touchscreen
	var obj = document.getElementById('primaryCanvas');
	obj.addEventListener('touchmove', function(event) 
	{
		if(gameStarted)
		{
			var z = 0; //limit touches to the 1st finger 
			//for (var z = 0; z < event.targetTouches.length; z++)
			{
				swipeLength++;
				if(swipeLength < 20)
				{
					var touch = event.targetTouches[z];
					var x = touch.pageX;
					var y = touch.pageY;
					targetShip(x,y);
				}
			}
			
			//superpower test
			if((event.targetTouches.length==2) && (swipeLength > 15) && (swipeLength < 20))
			{
				swipeLength = 100;
				for (var i = 0; i < ship.length; i++)
				{
					ship[i].health = 0;
					explodeSomething(ship[i].x,ship[i].y,"boom");
				}
			}
			
		}
		
	}, false);
	
	//event listener for starting a touch	
	obj.addEventListener('touchstart', function(event) 
	{
		
		//if there is only one finger starting to touch, reset the swipe length 
		//counter as we are starting a new swipe
		if(event.targetTouches.length==1)
			swipeLength = 0;
		
		touchText = "";
		//touchText = "touches: " + event.targetTouches.length;
		
		if(gameStarted)
		{
			for (var z = 0; z < event.targetTouches.length; z++)
			{
				var touch = event.targetTouches[z];
				var x = touch.pageX;
				var y = touch.pageY;
				targetShip(x,y);
				
				////
				//maybe we are trying to hit a panel and not a ship, whooops
				for (var i = 0; i < panelX.length; i++)
				{
					if(getDist(panelX[i]+25,panelY[i]+25,x,y)<40)
						layTrack(i);
				}
				/////
				
			}
		}
		
	}, false);
	
	//event listener for ending a touch
	obj.addEventListener('touchend', function(event) 
	{
		/*
		if(gameStarted)
		{
			
			for (var z = 0; z < event.targetTouches.length; z++)
			{
								
				var touch = event.targetTouches[z];
				var x = touch.pageX;
				var y = touch.pageY;
				targetShip(x,y);
			}
		}
		*/
		
	}, false);
	
	function canvasClick(event)
	{
		if(gameStarted)
		{
			var x = event.clientX;
			var y = event.clientY;
			targetShip(x,y);
			//targetShip(x+cameraX,y+cameraY);
		}
	}
	
	function playerMouseMove(event)
	{
		mouseX = event.clientX;
		mouseY = event.clientY;
		adjustedMouseX = mouseX+cameraX;
		adjustedMouseY = mouseY+cameraY;
	}
	
	//-------------------------------------------
	//gameplay / general functions
	//-------------------------------------------
		
	//called when the player presses a key to lay track
	function layTrack(p)
	{
				
		//attempt to re-rail a derailed train
		//doesn't quite work yet
		if(map[Math.floor(comp[0].x/tileSize)][getTileY(comp[0].y)].b=="d")
		{
			lastRailX = Math.floor(comp[0].x/tileSize);
			lastRailY = Math.floor(comp[0].y/tileSize);
			railOption[p] = "up";
			comp[0].direction = "up";
		}
		
		//lay an appropriate track
		if((railOption[p]=="up") || (railOption[p]=="topleft") || (railOption[p]=="topright"))
		{
			lastRailY = lastRailY - 1;
			if(lastRailY<0)
				lastRailY = insaneHeight-1;	//mapHeight
		}
		else if((railOption[p]=="left") || (railOption[p]=="bottomleft"))
		{
			lastRailX = lastRailX - 1;
			if(lastRailX<0)
				lastRailX = 0;
		}
		else if((railOption[p]=="right")  || (railOption[p]=="bottomright"))
		{
			lastRailX = lastRailX + 1;
			if(lastRailX>insaneWidth-1) //mapWidth
				lastRailX = insaneWidth-1;
		}
		
		//we should probably add in tracks that are combined with dangers here
		//otherwise there would only be left, straight, right? (for tracks that work)
				
		//lastRailY = lastRailY - 1;
		//if(lastRailY<0)
		//	lastRailY = mapHeight-1;
			
		//map[lastRailX][lastRailY].b = "r";
		map[lastRailX][lastRailY].b = railOption[p];
		lastRailType = railOption[p];
		
		//assign a random key to be pressed
		keyArray = 	[
					['A','VK_A'],
					['B','VK_B'],
					['C','VK_C'],
					['D','VK_D'],
					['E','VK_E'],
					['F','VK_F'],
					['G','VK_G'],
					['H','VK_H'],
					['I','VK_I'],
					['J','VK_J'],
					['K','VK_K'],
					['L','VK_L'],
					['M','VK_M'],
					['N','VK_N'],
					['O','VK_O'],
					['P','VK_P'],
					['Q','VK_Q'],
					['R','VK_R'],
					['S','VK_S'],
					['T','VK_T'],
					['U','VK_U'],
					['V','VK_V'],
					['W','VK_W'],
					['Y','VK_Y'],
					['X','VK_X'],
					['Z','VK_Z']
					];
		
		for(var i = 0; i < 24; i++)
		{
			var randomKey = Math.floor(Math.random() * keyArray.length);
			keyArray.splice(randomKey,1);
		}
		
		//override so that you only ever get Q/W as the required keys
		keyArray = 	[
					['Q','VK_Q'],
					['W','VK_W']
					];
		
		
		//select an appropriate matching rail tile
		railRep = [];
		railOption = [];
		for(var i = 0; i < 2; i++)
		{
			//railOption[i] = "up"; //easy mode
			
			var r = Math.floor(Math.random()*3);
			if(lastRailType=="up")
			{
				if(r==0)
					railOption[i] = "up"
				else if(r==1)
					railOption[i] = "topleft"
				else if(r==2)
					railOption[i] = "topright";
			}
			//else if(lastRailType=="down")
			//{
			//	if(r==0)
			//		railOption[i] = "down"
			//	else if(r==1)
			//		railOption[i] = "bottomleft"
			//	else if(r==2)
			//		railOption[i] = "bottomright"
			//}
			else if(lastRailType=="left")
			{
				var r = Math.floor(Math.random()*2); //will stop things going down
				if(r==0)
					railOption[i] = "left"
				else if(r==1)
					railOption[i] = "bottomleft"
				else if(r==2)
					railOption[i] = "topleft";
				
			}
			else if(lastRailType=="right")
			{
				var r = Math.floor(Math.random()*2);
				if(r==0)
					railOption[i] = "right"
				else if(r==1)
					railOption[i] = "bottomright"
				else if(r==2)
					railOption[i] = "topright";
				
			}
			else if(lastRailType=="topleft")
			{
				railOption[i] = "right";
			}
			else if(lastRailType=="topright")
			{
				railOption[i] = "left";
			}
			else if(lastRailType=="bottomleft")
			{
				railOption[i] = "up";
			}
			else if(lastRailType=="bottomright")
			{
				railOption[i] = "up";
			}
			else // still need the other 4 types
			{
				alert("heywhat");
			}
			
			//railOption[i] = "up"; //easy mode
			
			if((railOption[i]=="left") || (railOption[i]=="right"))
				railRep[i] = railH
			else if((railOption[i]=="up") || (railOption[i]=="down"))
				railRep[i] = rail
			else if(railOption[i]=="topleft")
				railRep[i] = railTopLeft
			else if(railOption[i]=="topright")
				railRep[i] = railTopRight
			else if(railOption[i]=="bottomleft")
				railRep[i] = railBottomLeft
			else if(railOption[i]=="bottomright")
				railRep[i] = railBottomRight
			else
			{
				alert("what");
			}
			
		}
		
	}
		
	//the map is scrolling so this function exists as a way to
	//get the tileY coord (map[x][THISY]) at a given onscreen Y coord 
	function getTileY(givenY)
	{
		var fmlY = tileSize + Math.floor(givenY - yTravelled);
		if(fmlY < 0)
			fmlY = fmlY + boundingHeight+64;
		return(Math.floor(fmlY/tileSize));
	}
	
	//called when you click the canvas or touch a touchscreen
	//squish fans that are clicked on
	function targetShip(x,y)
	{
		if(gameStarted)
		{
		
			//x = x +16;
			//y = y +16;
			x=x+cameraX;
			y=y+cameraY;
		
			var lethalHit = true;		
			var targetHit = false;
			for (var i = 0; i < ship.length; i++)
			{
				if(getDist(ship[i].x+16,ship[i].y+16,x,y)<32) 
				{
					targetHit = true;
					ship[i].health = ship[i].health - 1;
					
					if(ship[i].health > 0)
						lethalHit = false;
				}
							
			}
			
			if(targetHit==false)
			{
				explodeSomething(x-cameraX,y-cameraY,"spark");
			}
			else if((targetHit==true) && (lethalHit==false))
			{
				explodeSomething(x-cameraX,y-cameraY,"ting");
			}
				
			// If there's exactly one finger inside this element
			//  if (event.targetTouches.length == 1) 
			//  {
			//	var touch = event.targetTouches[0];
				//touchText = touch.pageX + 'px; ' + touch.pageY + 'px';
				// Place element where the finger is
				//obj.style.left = touch.pageX + 'px';
				//obj.style.top = touch.pageY + 'px';
			  //}
		  
		}
	}
		
	function respawnShip(p)
	{
		ship[p].x = comp[0].x - (Math.floor(Math.random() * (boundingWidth))*0.5) + (Math.floor(Math.random() * (boundingWidth))*0.5);
		ship[p].y = comp[0].y-(boundingHeight/2)-32;
			
		//if(ship[p].type=="spy")
		//	ship[p].y = 50+Math.floor(Math.random() * (boundingHeight-140))+boundingY;
		
		ship[p].targetX = Math.floor(Math.random() * boundingWidth)+boundingX;
		ship[p].targetY = boundingHeight;
		
		if(ship[p].type=="fan")
		{
			var r = Math.floor(Math.random() * 9)+1;
			ship[p].image.src = "images/fan"+r+".png";
			var r = Math.floor(Math.random() * 3);
			if(r==0)
			{
				ship[p].targetX = comp[0].x;
				ship[p].targetY = comp[0].y;
			}
			
		}
		
	}
	
	//called when the story dialog (storyScreen) is open 
	//and you click the "continue button"
	function continueText()
	{
		storyTextID++;
		
		//CHAPTER ONE
		if(storyTextID==1)
			document.getElementById("storyText").innerHTML = "There was a reverberating clonk as the back carriage was finally pried loose, and the yelling soldiers were left behind. Now there were just four carriages of refugees, a dozen railway employees and some militiamen, and a train that wouldn’t stop. The needle on every meter and gauge was deep in the red, or bouncing around so wildly as to be useless. Elisabeth sighed and wiped her face with a rag, leaving another greasy blotch. She looked around for Chief Engineer Theodophus Grimbold, who, of course, was nowhere to be found."
		else if(storyTextID==2)
			document.getElementById("storyText").innerHTML = "She took a chance and left the engine room to push through the first passenger car, filled with grim, cloth-capped civilians sitting in terrified silence. to the roofless carriage they were using to store supplies. She had a brief conversation with Sally, who was cleaning their collection of mismatched muskets, and eventually found Grimbold, hanging off the side of the train by what appeared to be his trusty protractor wedged in the door jamb, grinned wildly."
		else if(storyTextID==3)
			document.getElementById("storyText").innerHTML = "'The brakes!' </br></br> 'WHAT?!'</br></br> 'THE BRAKES!' she screamed over the sound of the screaming train. 'THE BRAKES WON'T WORK!' </br></br> He shook his head and clambered on top of the train, pulling his flat cap low against the wind, and crawled over to her. “THE B-” <br/><br/> 'You don’t need to shout, I’m right here. And yes, it’s the brakes. I had";
		else if(storyTextID==4)
			document.getElementById("storyText").innerHTML = "a look just now – the soldiers must have cut them when we were trying to leave the station.' <br/><br/>She blinked at him. 'What does that mean?' <br/><br/> 'It means we are royally fucked, Madam Conductor.' <br><br/> Elisabeth groaned."
		else if(storyTextID==5)
			document.getElementById("storyText").innerHTML = "- End of passage -"
		else if(storyTextID==6)
			continueGame()		
		
		//CHAPTER TWO
		else if(storyTextID==7)
			document.getElementById("storyText").innerHTML = "- Chapter 2 text here -"
		else if(storyTextID==8)
			continueGame()	
		else
			continueGame();
	}
	
	//called when you click the restart/continue button after
	//winning or losing a level
	function showStory()
	{
		document.getElementById('menuScreen').style.display = "none";
		document.getElementById('storyScreen').style.display = "block";
	}
	
	//called to resume the main game after pausing it to show
	//the win/lose/story screens
	function continueGame()
	{
		gameStarted = true;
		introScreenDone = true;
		document.getElementById('menuScreen').style.display = "none";
		document.getElementById('storyScreen').style.display = "none";
		document.getElementById('winScreen').style.display = "none";
		document.getElementById('loseScreen').style.display = "none";
		document.getElementById('primaryCanvas').style.display = "block";
		
	}
	
	//called to show the failure screen
	function showDefeat()
	{
		gameStarted = false;
		document.getElementById('score_fail').innerHTML = "SCORE: " + playerScore;
		document.getElementById('level_fail').innerHTML = "LEVEL: " + playerLevel;
		playerScore = 0;
		playerLevel = 1;
		playerHealth = 10;
		hello();
		document.getElementById('loseScreen').style.display = "block";
		document.getElementById('primaryCanvas').style.display = "none";
	}
	
	//called to show the win screen
	function showActualWin()
	{
		gameStarted = false;
		document.getElementById('score_win').innerHTML = "SCORE: " + playerScore;
		document.getElementById('level_win').innerHTML = "LEVEL: " + playerLevel;
		playerLevel++;
		hello();
		document.getElementById('winScreen').style.display = "block";
		document.getElementById('primaryCanvas').style.display = "none";
	}
	
	//called to show the win screen after a brief pause
	function showWin()
	{
		finalCountdown = 1;
	}
	
	//A BIG ONE!
	//This is the first function called when the page loads
	//We definte our starting attributes and shit here,
	//and then later set up /reset values in hello()
	function startingSetup()
	{
		isMovingUp = false;
		storyTextID = 0;
		continueText();
		
		mouseX = 0;
		mouseY = 0;
		//alert("hi");
		adjustedMouseX = 0;
		adjustedMouseY = 0;
		cameraX = 0;
		cameraY = 0;
		
		//TryPlay("mayhem");
		gameStarted = false;
		introScreenDone = false;
		waveMode = false;
		document.getElementById('menuScreen').style.display = "block";
		document.getElementById('loseScreen').style.display = "none";
		document.getElementById('winScreen').style.display = "none";
		
		document.getElementById('storyScreen').style.display = "none";
		
		var w = window,
		d = document,
		e = d.documentElement,
		g = d.getElementsByTagName('body')[0],
		x = w.innerWidth || e.clientWidth || g.clientWidth,
		y = w.innerHeight|| e.clientHeight|| g.clientHeight;
		//alert(x + ' × ' + y);
				
		//if(isMobileDevice()==false)
		//{
		//	x = 500;
		//}
		
		canvas = document.getElementById("primaryCanvas");
		canvas.width = x-50; //1920
		canvas.height = y-30; //900
		
		boundingX = 0;
		boundingY = 0;
		boundingWidth = x-30;
		boundingHeight = y-30;
		
		//boundingX = 150;
		//boundingY = 150;
		//boundingWidth = x-300;
		//boundingHeight = y-300;
		
		panelX = [];
		panelY = [];
		panelX[0] = boundingX+30;
		panelY[0] = boundingHeight-300+150;
		panelX[1] = boundingWidth-100;
		panelY[1] = boundingHeight-300+150;
		
		context = document.getElementById('primaryCanvas').getContext('2d');
		
		
	
		
		
			
		bloodX = []
		bloodY = []
		bloodID = [];
		
		mapWidth = Math.floor(boundingWidth/tileSize); //33 //20
		mapHeight = Math.floor(boundingHeight/tileSize)+3;
		
		//alert(mapWidth);
		insaneWidth = 300; //150
		insaneHeight = 300; //50
		map = [];
		
		playerScore = 0;
		enemiesLeft = 20;
		
		
		
		shipDY = 0;
		shipDX = 0;
		shipX = 10;
		shipY = 10;
		starX = 0;
		starY = 0;
		fogX = 0;
		fogY = 0;
		
		screenShakeDuration = 0;
		
		finalCountdown = 5000;
		
		lightningCounter = 0;
		starTimer = 0;
		starX = 0;
		starX_right = 1920;
		fogX = 0;
		fogX_right = 1920;
		backX = 3000;
		
		comp = [];
		player = new entity(528,488,"player");
		player.dx = 0;
		player.dy = -0.5; //-1
		
		/*
		star = [];
		for (var i = 0; i < 270; i++) //500 //270
		{
			var rX = Math.floor(Math.random() * boundingWidth)+boundingX;
			var rY = Math.floor(Math.random() * boundingHeight)+boundingY;
			star[star.length] = new heavenlyBody(rX,rY);
		}
		*/
		
		
		hello();
		
		grindTimer = 0;
			
	}
	
	//called on start/win/lose to reinitialize/reset important values
	//and set up some other shit
	function hello()
	{
		
		playerHealth = 10;
		distanceToGoal = 1000;
		distanceTravelled = 0;
	
		gameStarted = false;
		finalCountdown = 5000;
		
		chainActive = false;
		chainLength = 0;
		chainX = 0;
		
		swipeLength = 0;
		
		exp = [];
		ship = [];
		
		lastRailX = 150;
		lastRailY = 150-10;
		lastRailType = "up";
		railRep = [];
		railOption = [];
		railOption[0] = "up";
		railOption[1] = "up";
		railRep[0] = rail;
		railRep[1] = rail;
		yTravelled = 0;
		
		bloodX = []
		bloodY = []
		bloodID = [];
		
		//mapWidth = Math.floor(boundingWidth/tileSize); 
		//mapHeight = Math.floor(boundingHeight/tileSize)+3;
		
		map = [];
		for (x = 0; x < insaneWidth; x++)
		{
			map[x] = [];
			for (y = 0; y < insaneHeight; y++)
			{
				map[x][y] = new tile(".", "d", "500", true);
				map[x][y].x = x*tileSize;
				map[x][y].y = y*tileSize;
				var r = Math.floor(Math.random()*3); //4
				if(r==0)
					map[x][y].f = "a"
				else if(r==1)
					map[x][y].f = "b"
				else if(r==2)
					map[x][y].f = "c"
				else if(r==3)
				{
					if(Math.floor(Math.random()*10)>=8)
						map[x][y].f = "d"
					else
						map[x][y].f = "a";
				}
				
			}
		}
		
		x = lastRailX;
		for (y = lastRailY; y < lastRailY+100; y++)
		{
			map[x][y].b = "up";
		}
		
		comp = [];
		//comp[0] = new entity((lastRailX*tileSize)+16,32*8,"trainFront");
		var altValue = 16; //16
		comp[0] = new entity((lastRailX*tileSize)+altValue,((lastRailY*tileSize)+(32*8))+(32*0),"trainFront");
		comp[1] = new entity((lastRailX*tileSize)+altValue,((lastRailY*tileSize)+(32*8))+(32*1),"trainWood");
		comp[2] = new entity((lastRailX*tileSize)+altValue,((lastRailY*tileSize)+(32*8))+(32*2),"trainWood");
		comp[3] = new entity((lastRailX*tileSize)+altValue,((lastRailY*tileSize)+(32*8))+(32*3),"trainGoods");
		comp[4] = new entity((lastRailX*tileSize)+altValue,((lastRailY*tileSize)+(32*8))+(32*4),"trainBack");
				
		for (var i = 0; i < 4; i++)
		{
			comp[i].direction = "up";
			comp[i].dy = -0.5;
		}
		
		
		bloodX = [];
		bloodY = [];
		bloodID = [];
		
		
		if(playerLevel<=1)
		{
			distanceToGoal = 1000; 
			enemiesLeft = 20; // 10;
		}
		
		else if(playerLevel==2)
		{
			enemiesLeft = 20; //20;
		}
		
		else if(playerLevel==3)
		{
			enemiesLeft = 30;
		}
		
		else if(playerLevel==4)
		{
			enemiesLeft = 40;			
		}
		
		else if(playerLevel==5)
		{
			enemiesLeft = 50;
		}
		
		else
		{
			enemiesLeft = 60;
		}
		
		ship = [];
		for (var i = 0; i < 3; i++)
		{
			ship[ship.length] = new entity(10,10,"fan");
		}
		
		for (var i = 0; i < ship.length; i++)
		{
			respawnShip(i);
		}
		
		//playerScore = 0;
		
		screenShakeDuration = 0;
		
		//continueGame();
			
	}
	
	//star methods disabled but preserved 
	//if we want scrolling clouds and shit like that later
	/*
	function drawStars()
	{
		//do literally nothing 
		//drawR(scoutShip[engineFrame],player.x-cameraX,player.y-cameraY,player.rot+90,"primaryCanvas")
		
		for (var i = 0; i < star.length; i++)
		{
			//context.drawImage(turretImage,star[i].x-cameraX, star[i].y-cameraY);
			
			//new way, move the whole universe.
			star[i].dx = player.dx*star[i].distance*-1;
			star[i].dy = player.dy*star[i].distance*-1;
			star[i].x = star[i].x + star[i].dx;
			star[i].y = star[i].y + star[i].dy;
			
			//if((introScreenDone==true) && (gameStarted==false))
			if(document.getElementById("winScreen").style.display == "block")
				context.fillStyle = document.getElementById("titleText").style.color
			else if(document.getElementById("loseScreen").style.display == "block")
				context.fillStyle = "darkred";
			else
				context.fillStyle = star[i].colour;
				
			//context.fillRect(star[i].x, star[i].y,2,2);
			//if(variableStarSize)
			//{
				//if(star[i].type=="star")
					context.fillRect(star[i].x, star[i].y,star[i].radius,star[i].radius);
				//else
				//	context.drawImage(customStar[star[i].radius],star[i].x, star[i].y);
				
				
				//if(star[i].radius>=3)
				//	context.globalAlpha = 0.3;
				//context.fillRect(star[i].x, star[i].y,star[i].radius,star[i].radius);
				//context.globalAlpha = 1;
				//customStar
				
			//}
			//else
			//	context.fillRect(star[i].x, star[i].y,2,2);
			
			//if(star[i].colour=="nebula")
			//	context.drawImage(nebulaA,star[i].x-cameraX, star[i].y-cameraY);
			
			
			//}
			//old way, draw stars where they are
			//context.fillRect(star[i].x-cameraX, star[i].y-cameraY,2,2);
			
			
			//context.strokeStyle = star[i].colour;
			
			//context.beginPath();
            //context.arc(star[i].x-cameraX, star[i].y-cameraY, star[i].radius, 0, 2 * Math.PI, false);
            //context.fill();
            //context.stroke();
			
		}
		
		//reposition stars that leave the bounding box
		for (var i = star.length-1; i >= 0; i--)
		{
			//if	(
			//		(star[i].x<boundingX) || (star[i].y<boundingY) ||
			//		(star[i].x>boundingX+boundingWidth) || (star[i].y>boundingY+boundingHeight)
			//	)
			//	star[i].colour = "limegreen";
				
			if(star[i].x<boundingX)
				star[i].x = boundingX+boundingWidth;
			else if(star[i].x>boundingX+boundingWidth)
				star[i].x = boundingX;
			if(star[i].y<boundingY)
				star[i].y = boundingY+boundingHeight;
			else if(star[i].y>boundingY+boundingHeight)
			{
				star[i].y = boundingY;
				star[i].colour = greyShades[Math.floor(Math.random() * greyShades.length)];
				if(Math.floor(Math.random() * 10)>7)
					star[i].colour  = colorArray[Math.floor(Math.random() * colorArray.length)];
			}
		}
				
	}
	
	function old_drawStars()
	{
	
		
		starX = 0;
		
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starScape, starX, 0);
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starScape, starX_right, 0);
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starFog, fogX, 0);
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starFog, fogX_right, 0);
		//document.getElementById('primaryCanvas').getContext('2d').drawImage(cloudImg, fogX, 0);
		//document.getElementById('primaryCanvas').getContext('2d').drawImage(cloudImg, fogX_right, 0);
		
		//document.getElementById('primaryCanvas').getContext('2d').drawImage(cloudImg, 0, 0);
		
		
		enginesOn = 0.5;
				
		
		if(starTimer == 3)
		{
			starTimer = 0;
			fogX = fogX - (0.3*enginesOn)-0.3 -1;
			fogX_right = fogX_right - (0.3*enginesOn)-0.3 -1; //-2
			
			if(fogX<=-1920)
				fogX=1920;
				
			if(fogX_right<=-1920)
			fogX_right=1920;
		
		}
		
		if(starTimer == 1)
		{
			
			//starTimer = 0;
			//starX_right = starX_right - (0.3*enginesOn);// -0.3;
			//starX = starX - (0.3*enginesOn);//-0.3;
			
			//if(starX<=-1920)
			//	starX=1920;
				
			//if(starX_right<=-1920)
			//	starX_right=1920;
						
			
		}
		starTimer = starTimer +1;
	
	}
	*/
	
	function preShake() 
	{
	  context.save();
	  var dx = Math.random()*10;
	  var dy = Math.random()*10;
	  context.translate(dx, dy);  
	}
	
	function postShake() 
	{
		context.restore();
	}
	
	function drawAdjustedCamera()
	{
	
		context.clearRect(0, 0, canvas.width, canvas.height);
		
		//context.beginPath();
		//context.fillStyle = "black";
		//context.fillRect(boundingX+5, boundingY+5, boundingWidth-10, boundingHeight-10);
		//context.stroke();
		//context.closePath();
		
		cameraX = comp[0].x-canvas.width/2;
		cameraY = comp[0].y-canvas.height/2;
		
		//old_drawStars();
		//drawStars();
			
		if(gameStarted)
		{
		
			//document.getElementById("primaryCanvas").getContext('2d').drawImage(dirt, 50, 50);
			
			//determine what section of the map is within the viewscreen
			//we don't need to draw extra shit
			startingYTile = (Math.floor((0-boundingY-cameraY)/tileSize)*-1)-1;
			if(startingYTile < 0)
				startingYTile = 0;
			
			endingYTile = startingYTile + Math.floor(boundingHeight/tileSize)+2;
			if(endingYTile>=map[0].length)
				endingYTile = map[0].length-1;
			
			startingXTile = (Math.floor((0-boundingX-cameraX)/tileSize)*-1)-1;
			if(startingXTile < 0)
				startingXTile = 0;
			
			endingXTile = startingXTile + Math.floor(boundingWidth/tileSize)+2;
			if(endingXTile>=map.length)
				endingXTile = map.length-1;
			
			//don't draw the whole fucking map, just the tiles that are visible (and a lil extra)
			//for (x = 0; x < insaneWidth; x++)
			for (x = startingXTile; x < endingXTile; x++)
			{
				//for (y = 0; y < insaneHeight; y++)
				for (y = startingYTile; y < endingYTile; y++)
				{
					if(map[x][y].f=="a")
						tempImg = dirt;
					else if(map[x][y].f=="b")
						tempImg = dirtB
					else if(map[x][y].f=="c")
						tempImg = dirtC
					else if(map[x][y].f=="d")
						tempImg = stone;
					
					context.drawImage(tempImg, map[x][y].x-cameraX, map[x][y].y-cameraY);
					
					//scrolling text check
					/*
					if(x==1)
					{
						context.fillStyle = 'white';
						var maxWidth = 500;//400
						var lineHeight = 25;
						wrapText(context, ""+y+","+map[x][y].y, map[x][y].x, map[x][y].y, maxWidth, lineHeight);
					}
					*/
				
					//need to add up/down 
					//left right here 
					//also think about directions of things, we have some issues 
					//not sure how approaching rails from diff directions changes things 
			
					if((map[x][y].b=="up") || (map[x][y].b=="down"))
						tempImg = rail
					else if((map[x][y].b=="left") || (map[x][y].b=="right"))
						tempImg = railH
					else if(map[x][y].b=="railH")
						tempImg = railH
					else if(map[x][y].b=="topleft")
						tempImg = railTopLeft;
					else if(map[x][y].b=="topright")
						tempImg = railTopRight
					else if(map[x][y].b=="bottomleft")
						tempImg = railBottomLeft
					else if(map[x][y].b=="bottomright")
						tempImg = railBottomRight;
					
					context.drawImage(tempImg, map[x][y].x-cameraX, map[x][y].y-cameraY);
					
				}
			}
			
			
			
			trainX = lastRailX*tileSize;
			trainY = boundingHeight-400;
						
			for (var i = 0; i < bloodX.length; i++)
			{
				//if(withinBoundsWH(bloodX[i]-cameraX,bloodY[i]-cameraY,32,32)==true)
					context.drawImage(bloodDecal[bloodID[i]], bloodX[i]-cameraX, bloodY[i]-cameraY);
			}
			
			for (var i = 0; i < ship.length; i++)
			{
				if(ship[i].type == "fan")
					drawR(ship[i].image,ship[i].x-cameraX,ship[i].y-cameraY,0,"primaryCanvas")
				else
					drawR(ship[i].image,ship[i].x-cameraX,ship[i].y-cameraY,ship[i].rot+90,"primaryCanvas");
			}
			
			for (var i = 0; i < comp.length; i++)
			{
				
				drawR(comp[i].image,comp[i].x-cameraX,comp[i].y-cameraY,comp[i].rot,"primaryCanvas");
				
				/*if(comp[i].direction=="up")
					drawR(comp[i].image,comp[i].x-cameraX,comp[i].y-cameraY,comp[i].rot+90,"primaryCanvas")
				else if(comp[i].direction=="left")
					drawR(comp[i].image,comp[i].x-cameraX,comp[i].y-cameraY,comp[i].rot+90-45,"primaryCanvas")
				else if(comp[i].direction=="right")
					drawR(comp[i].image,comp[i].x-cameraX,comp[i].y-cameraY,comp[i].rot+90+45,"primaryCanvas")
				else if(comp[i].direction=="down")
					drawR(comp[i].image,comp[i].x-cameraX,comp[i].y-cameraY,comp[i].rot+90+90,"primaryCanvas");*/
			}
									
			drawR(trainTurret, comp[2].x-cameraX,comp[2].y-cameraY,getRotFromMouseXY(comp[2].x,comp[2].y)+90,"primaryCanvas");
			
			//for (var i = 1; i < expAnim.length; i++)
			//{
			//	context.drawImage(expAnim[i], 100, 0+i*100);
			//}
			
			//context.drawImage(greenSquare, comp[0].x, comp[0].y);
			
			
		}
		//draw explosions
		for (var i = exp.length-1; i >= 0; i--)
		{
			document.getElementById(exp[i].canvas).getContext('2d').drawImage(explosionSheet, 50*exp[i].frame, 0, 50, 50, exp[i].x-35-cameraX, exp[i].y-35-cameraY, 50, 50);
			
			exp[i].frame = exp[i].frame + 1;
			if(exp[i].frame==11)
			{
				exp.splice(i,1);
			}
		}
		
		exp_update();
		
		sCurr = "SCORE: " + playerScore;
		var maxWidth = 500;//400
		var lineHeight = 25;
		
		//context.font = '16pt Calibri';
		//context.fillStyle = 'white';
		
		//context.font = "30px Arial";
		context.font = '16pt Calibri';
		if(screenShakeDuration>0)
			context.fillStyle = 'red';
		else
			context.fillStyle = 'darkred';
		
		if(gameStarted)
		{
		
			//wrapText(context, sCurr, (boundingWidth/2)-30, boundingHeight-50, maxWidth, lineHeight);
			context.fillStyle = 'white';
			
			//wrapText(context, "ENEMIES LEFT: " +enemiesLeft, (boundingWidth/2)-80, 25, maxWidth, lineHeight);
			
			//wrapText(context, "DISTANCE TRAVELLED: " +Math.floor(distanceTravelled) +"m", (boundingWidth/2)-150, 25, maxWidth, lineHeight);
			wrapText(context, "DISTANCE TO GOAL: " +Math.floor(distanceToGoal) +"m", (boundingWidth/2)-150, 25, maxWidth, lineHeight);
			
			
			//maxWidth = 300;
			//wrapText(context, touchText, 25, 50, maxWidth, lineHeight);
					
			//left and right panels and rail icons
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[0], panelY[0]);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[0], panelX[0]+8, panelY[0]+9);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[1], panelY[1]);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[1],panelX[1]+8, panelY[1]+9);
					
			//left and right panels for keys 
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[0], panelY[0]+45); //boundingHeight-80
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[1], panelY[1]+45);
			
								
			
			/*
			startingTile = Math.floor((0-boundingY-cameraY)/tileSize)*-1;
			if(startingTile < 0)
				startingTile = 0;
			
			endingTile = startingTile + Math.floor(boundingHeight/tileSize);
			if(endingTile>=map[0].length)
				endingTile = map[0].length-1;
			*/
			
			
			context.font = '24pt Calibri';
			context.fillStyle = 'white';
			adjustX = 13;
			adjustY = 80;
			wrapText(context, keyArray[0][0], panelX[0]+adjustX, panelY[0]+adjustY, maxWidth, lineHeight);
			wrapText(context, keyArray[1][0], panelX[1]+adjustX, panelY[0]+adjustY, maxWidth, lineHeight);
					
			//wrapText(context, "Map " + Math.floor(comp[0].x/tileSize) + ";" + getTileY(comp[0].y) + " is " + map[Math.floor(comp[0].x/tileSize)][getTileY(comp[0].y)].b, 300, 540, maxWidth, lineHeight);
			
					
			//endingTile = Math.floor((0-boundingHeight-cameraY)/tileSize)*-1;
			
			/*
			
			context.fillStyle = 'black';
			wrapText(context, "cameraY: "+cameraY, 300, 300, maxWidth, lineHeight);
			wrapText(context, "map[0][0].y: "+map[0][0].y, 300, 360, maxWidth, lineHeight);
			wrapText(context, "diff: "+(map[0][0].y-boundingY-cameraY), 300, 390, maxWidth, lineHeight);
			wrapText(context, "st: "+startingYTile, 300, 420, maxWidth, lineHeight);
			wrapText(context, "et: "+endingYTile, 300, 450, maxWidth, lineHeight);
			
			wrapText(context, "stX: "+startingXTile, 300, 480, maxWidth, lineHeight);
			wrapText(context, "etX: "+endingXTile, 300, 520, maxWidth, lineHeight);
			
			
			
			
			//reports on some of the tile/track positioning
						
			x = 1;
			for (y = 0; y < insaneHeight; y++)
			{
				context.fillStyle = 'white';
				var maxWidth = 500;//400
				var lineHeight = 25;
				wrapText(context, ""+y+";"+Math.floor(map[x][y].y), map[x][y].x-cameraX, map[x][y].y-cameraY+30, maxWidth, lineHeight);
			}
			context.fillStyle = 'white';
			*/
			
			
			/*			
			maxWidth = 1000;
			wrapText(context, "The car is at "+comp[0].y + " pixels", 300, 300, maxWidth, lineHeight);
			wrapText(context, "Objectively, the the tile would be: "+comp[0].y + "/ tileSize, so " +Math.floor(comp[0].y/tileSize), 300, 330, maxWidth, lineHeight);
			wrapText(context, "car y - distanceShifterd = " +Math.floor(comp[0].y - yTravelled), 300, 365, maxWidth, lineHeight);
			wrapText(context, "The tiles have been shifted "+ Math.floor(yTravelled) + " pixels from their original start", 300, 400, maxWidth, lineHeight);
			wrapText(context, "tile 8 y: " +Math.floor(map[0][8].y) + " vs " +Math.floor(comp[0].y + yTravelled), 300, 425, maxWidth, lineHeight);
			
			//player.dy = -0.5; //0/01
			
			var crazyY = Math.floor(comp[0].y + yTravelled);
			if(crazyY > boundingHeight+32)
				crazyY = crazyY - (boundingHeight+64);
			
			wrapText(context, "tile 8 y: " +Math.floor(map[0][8].y) + " vs " +crazyY, 300, 455, maxWidth, lineHeight);
			wrapText(context, "The train might be on tile: " + getTileY(comp[0].y), 300, 510, maxWidth, lineHeight);
			wrapText(context, "Map " + Math.floor(comp[0].x/tileSize) + ";" + getTileY(comp[0].y) + " is " + map[Math.floor(comp[0].x/tileSize)][getTileY(comp[0].y)].b, 300, 540, maxWidth, lineHeight);
			
			*/
			
			
			if(map[Math.floor(comp[0].x/tileSize)][getTileY(comp[0].y)].b=="d")
			{
				//train not on a rail
				//alert("hello");
				grindTimer++;
				if(grindTimer>10)
				{
					grindTimer = 0;
					
					explodeSomething(comp[0].x-16-cameraX,comp[0].y+16-cameraY,"spark");
					explodeSomething(comp[0].x+16-cameraX,comp[0].y+16-cameraY,"spark");
					//playerHealth--;
					if(playerHealth <= 0)
					{
						showDefeat();
					}
				}
				
				
				
			}
			
		
			startingX = (playerHealth*16)-16;
			for (var i = 0; i < playerHealth; i++)
			{
				document.getElementById("primaryCanvas").getContext('2d').drawImage(heartFull, startingX+(boundingWidth/2)-(32*i), boundingHeight-40);
			}
		
		}
		
		
		
	}
		
	
	function rotateA2B(a,b)
	{
		x2 = b.x;
		y2 = b.y;
		x1 = a.x;
		y1 = a.y;
		
		var deltaX = x2 - x1;
		var deltaY = y2 - y1;
		var rad = Math.atan2(deltaY, deltaX);
		var deg = rad * (180 / Math.PI)
		
		a.rot = deg;
		
	}
	
	function rotateShipToMouseXY(pShip)
	{
		//rotate pShip to face mouse cursor
		x2 = adjustedMouseX;
		y2 = adjustedMouseY;
		x1 = pShip.x;
		y1 = pShip.y;
		
		var deltaX = x2 - x1;
		var deltaY = y2 - y1;
		var rad = Math.atan2(deltaY, deltaX);
		var deg = rad * (180 / Math.PI)
		
		pShip.rot = deg;
	}
	
	function getRotFromMouseXY(x1,y1)
	{
		x2 = adjustedMouseX;
		y2 = adjustedMouseY;
		
		var deltaX = x2 - x1;
		var deltaY = y2 - y1;
		var rad = Math.atan2(deltaY, deltaX);
		var deg = rad * (180 / Math.PI)
		
		return(deg);
	}
	
	
	function changeRotation(rot,change)
	{
		extraRot = 0;
		rot=rot+change;
		if(rot>360)
		{
			extraRot = rot-360;
			rot = 0+extraRot;
		}
		else if(rot<0)
		{
			extraRot = rot*-1;
			rot = 360 - extraRot;
		}
		return(rot);
	}
	
	function toRadians (angle) 
	{
		return angle * (Math.PI / 180);
	}
	
	function withinBounds(x,y)
	{
		if	(
				(x<boundingX) || (y<boundingY) ||
				(x>boundingX+boundingWidth) || (y>boundingY+boundingHeight)
			)
			return(false)
		else
			return(true);
	}
	
	function withinBoundsWH(x,y,w,h)
	{
		if	(
				(x<boundingX-(w/2)) || (y<boundingY-(h/2)) ||
				(x>boundingX+boundingWidth+(w/2)) || (y>boundingY+boundingHeight+(h/2))
			)
			return(false)
		else
			return(true);
	}
	
	
	function drawR(image,x,y,rot,c)
	{
		//if(withinBounds(x,y))
		if(withinBoundsWH(x,y,image.width,image.height))
		{
			var canvas = document.getElementById(c);
			var context = document.getElementById(c).getContext('2d');
			
			//var x = 748;//canvas.width / 2;
			//var y = 567;//canvas.height / 2;
			var width = image.width;
			var height = image.height;

			angleInRadians = toRadians(rot);
			
			context.translate(x, y);
			context.rotate(angleInRadians);
			context.drawImage(image, -width / 2, -height / 2, width, height);
			context.rotate(-angleInRadians);
			context.translate(-x, -y);
		}
	}
	
	function handleTrainMovement()
	{
		
		/*
		var i = 0;
		//for (var i = comp.length-1; i >= 0; i--)
		{
			if(comp[i].direction=="up")
			{
				comp[i].dx = 0;
				comp[i].dy = -0.5;
			}
			else if(comp[i].direction=="down")
			{
				comp[i].dx = 0;
				comp[i].dy = 0.5;
			}
			else if(comp[i].direction=="left")
			{
				comp[i].dy = 0;
				comp[i].dx = -0.5;
			}
			else if(comp[i].direction=="right")
			{
				comp[i].dy = 0;
				comp[i].dx = 0.5;
			}
			comp[i].x += comp[i].dx*3;
			comp[i].y += comp[i].dy*3;
		}
		*/
		
		
		isMovingUp = false;
					
		for (var i = comp.length-1; i >= 0; i--)
		{
			var tileX = Math.floor(comp[i].x/tileSize);
			var tileY = getTileY(comp[i].y);
					
			if((map[tileX][tileY].b=="up") || (map[tileX][tileY].b=="bottomleft") || (map[tileX][tileY].b=="bottomright"))
			{
				comp[i].dx = 0;
				comp[i].dy = -0.5;
				comp[i].direction = "up";
							
				if(map[tileX][tileY].b=="up")
					comp[i].rot = 360
				else if(map[tileX][tileY].b=="bottomleft")
					comp[i].rot = 315
				else if(map[tileX][tileY].b=="bottomright")
					comp[i].rot = 45;
				comp[i].rot = 360;
								
			}
			else if(map[tileX][tileY].b=="down")
			{
				comp[i].dx = 0;
				comp[i].dy = 0.5;
				comp[i].direction = "down";
				comp[i].rot = 180;
			}			
			else if((map[tileX][tileY].b=="topleft") || (map[tileX][tileY].b=="right"))
			{
				comp[i].dy = 0;
				comp[i].dx = 0.5;
				comp[i].direction = "right";
				if(map[tileX][tileY].b=="right")
					comp[i].rot = 90
				else if(map[tileX][tileY].b=="topleft")
					comp[i].rot = 45;
				comp[i].rot = 90;
			}
			else if((map[tileX][tileY].b=="topright") || (map[tileX][tileY].b=="left"))
			{
				comp[i].dy = 0;
				comp[i].dx = -0.5;
				comp[i].direction = "left";
				//comp[i].rot = 270;
				if(map[tileX][tileY].b=="left")
					comp[i].rot = 270
				else if(map[tileX][tileY].b=="topright")
					comp[i].rot = 315;
				comp[i].rot = 270;
			}
			//else
			//	alert("DERAILED");
				//player.dy = -0.1;
				
			comp[i].x += comp[i].dx*1;
			comp[i].y += comp[i].dy*1;
			
		}
		
		distanceToGoal += comp[0].dy;
		distanceTravelled -= comp[0].dy;
		
		if(distanceToGoal<=0)
		{
			distanceToGoal = 0;
			showWin();
		}
		
		
		for (var i = bloodY.length-1; i >= 0; i--)
		{
			if(withinBoundsWH(bloodX[i]-cameraX,bloodY[i]-cameraY,32,32)==false)
			{
				bloodX.splice(i,1);
				bloodY.splice(i,1);
				bloodID.splice(i,1);
			}
		}
		
		/*
		if(comp[0].dy!=0)
			isMovingUp = true;
		
		if(isMovingUp)
		yTravelled = yTravelled - comp[0].dy; //player.dy;
		if(yTravelled > boundingHeight+32)
			yTravelled = -31;
				
		for (x = 0; x < mapWidth; x++)
		{
			for (y = 0; y < mapHeight; y++)
			{
				if(isMovingUp)
				map[x][y].y = map[x][y].y - comp[0].dy;//player.dy;
				if(map[x][y].y > boundingHeight+32) //64
				{
					map[x][y].y = -31;//0 //-31
					
					
					map[x][y].b = ".";
					var r = Math.floor(Math.random()*3); //4
					if(r==0)
						map[x][y].f = "a"
					else if(r==1)
						map[x][y].f = "b"
					else if(r==2)
						map[x][y].f = "c"
					else if(r==3)
						map[x][y].f = "d";
				
				}
			}
		}
		*/
		
		
	}
	
	function handleShipMovement()
	{
		//for (var i = ship.length-1; i >= 0; i--)
		for (var i = 0; i < ship.length; i++)
		{
			
			//////////////////
			//handle turning 
			//////////////////
			
			if(waveMode)
			{
				//don't rotate the ships
				//ship[i].rot = changeRotation(ship[i].rot,ship[i].turningSpeed);
			}
			else
			{
			
				if(ship[i].type=="fan")
				{
					ship[i].targetX = comp[0].x;
					ship[i].targetY = comp[0].y;
				}
				
				x2 = ship[i].targetX;//player.x;
				y2 = ship[i].targetY;//player.y;
				x1 = ship[i].x;
				y1 = ship[i].y;
				
				var deltaX = x2 - x1;
				var deltaY = y2 - y1;
				var rad = Math.atan2(deltaY, deltaX);
				var deg = rad * (180 / Math.PI)
				
				idealRotation = deg;
				if(deg < 0)
					idealRotation = 360+deg;
				
				idealRotation = Math.floor(idealRotation);
				var turning = true;
				var leftTurnRot = Math.floor(ship[i].rot);
				var leftTurn = 0;
				while(turning)
				{
					leftTurn++;
					
					leftTurnRot = changeRotation(leftTurnRot,-1);
					
					if(leftTurnRot==idealRotation)
						turning = false;
									
					if(leftTurn>370)
					{
						//alert(idealRotation + ";" + leftTurn + ";" + rightTurn);
						turning = false;
					}
				}
				
				var turning = true;
				var rightTurnRot = Math.floor(ship[i].rot);
				var rightTurn = 0;
				while(turning)
				{
					rightTurn++;
					
					rightTurnRot = changeRotation(rightTurnRot,1);
				
					if(rightTurnRot==idealRotation)
						turning = false;

					if(rightTurn>370)
					{
						//alert(idealRotation + ";" + leftTurn + ";" + rightTurn);
						turning = false;
					}
				}
				
				if(leftTurn<rightTurn)
					ship[i].rot = changeRotation(ship[i].rot,-ship[i].turningSpeed)
				else
					ship[i].rot = changeRotation(ship[i].rot,ship[i].turningSpeed)
				
					
				if(i==0)
				{
					//rotDetail = xDiff + ";" + yDiff;
					//rotDetail = Math.floor(ship[i].rot)+ "; " + Math.floor(idealRotation) + "; " + Math.floor(dif);
					//rotDetail = idealRotation + ";" + leftTurn + ";" + rightTurn;
				}
			
			}
		
		
		
		
			//////////////////
			//handle thrust 
			//////////////////
			//thrust
			if(true)
			{
				ship[i].ax = Math.cos(ship[i].rot*Math.PI/180)*ship[i].accelerationPower;
				ship[i].ay = Math.sin(ship[i].rot*Math.PI/180)*ship[i].accelerationPower;
			}
			else
			{
				//no acceleration is being applied, so cancel acceleration
				ship[i].ax = 0;
				ship[i].ay = 0;
			}
			
			
			//update velocity
			ship[i].dx += ship[i].ax;
			ship[i].dy += ship[i].ay;
			
			var tempDX = ship[i].dx;
			var tempDY = ship[i].dy;
			
			tempSpeed = Math.sqrt(tempDX * tempDX + tempDY * tempDY);
			if (tempSpeed > ship[i].maxSpeed) 
			{
				//the resulting speed is always <= maxspeed (normed to that)
				//ship[i].dy *= ship[i].maxSpeed/tempSpeed;
				//ship[i].dx *= ship[i].maxSpeed/tempSpeed;
				
				ship[i].dy /= tempSpeed/ship[i].maxSpeed;
				ship[i].dx /= tempSpeed/ship[i].maxSpeed;
			}
			
			
			//decrease speed due to friction/brakes
			if (false)
			{	
				
				ship[i].dy *= playerFriction;
				if(((ship[i].dy > 0) && (ship[i].dy < 1)) || ((ship[i].dy < 0) && (ship[i].dy > -1)))
					ship[i].dy = 0;
				ship[i].dx *= playerFriction;
				if(((ship[i].dx > 0) && (ship[i].dx < 1)) || ((ship[i].dx < 0) && (ship[i].dx > -1)))
					ship[i].dx = 0;
			}
					
			
			//update position
			ship[i].x = ship[i].x + ship[i].dx;
			ship[i].y = ship[i].y + ship[i].dy;
			
			if(getDist(ship[i].x+16,ship[i].y+16,comp[0].x,comp[0].y)>900)
			{
				respawnShip(i);
			}
			
			/*
			if(ship[i].y > boundingHeight)
			{
				respawnShip(i);
			}
			
			if(ship[i].x > boundingWidth)
				ship[i].dx *= -1;
			
			if(ship[i].x < 0)
				ship[i].dx *= -1;
			*/
			
			//out of map bounds 
			/*
			if(ship[i].x > 1900)
				ship[i].dx *= -1;
			
			if(ship[i].y > 900)
				ship[i].dy *= -1;
			
			if(ship[i].x < 0)
				ship[i].dx *= -1;
			
			if(ship[i].y < 0)
				ship[i].dy *= -1;
			*/
		
			
		
		}
		
		/*
		for (var i = 0; i < 3; i++)
		{
			rotateShipToMouseXY(OT[i])
			OTR[i] = OTR[i] +1;
			if(OTR[i]>360)
				OTR[i] = 0;
			
			OT[i].x = player.x + Math.cos(OTR[i]*Math.PI/180)*50;
			OT[i].y = player.y + Math.sin(OTR[i]*Math.PI/180)*50;
		}
		*/
		
	}
	
	function handleGameLogic()
	{
	
		for (var i = ship.length-1; i >= 0; i--)
		{
			
			if(waveMode)
			{
				if(ship[i].health <= 0)
				{
					
					playerScore = playerScore + 1;
					screenShakeDuration = 15;
							
					exp[exp.length] = new explosion(ship[i].x+16,ship[i].y+16,"exp");
					
					
					enemiesLeft--;
					
					
					ship.splice(i,1);
					
					if(enemiesLeft<=0)
						showWin();
					
					
						
					
				}
				else if((ship[i].health == 5000) && (playerHealth > 0))
				{
					enemiesLeft--;
					ship.splice(i,1);
					//if(enemiesLeft<=0)
					//	showWin();
				}

			}
			else 
			{
				
				//check for contact with train compartments
				for (var z = comp.length-1; z >= 0; z--)
				{
					if((ship[i].health!=-100)&&(getDist(ship[i].x+16,ship[i].y+16,comp[z].x,comp[z].y)<32))
					{
						ship[i].health = -100;
						screenShakeDuration =15;
						playerHealth--;
						if(playerHealth <= 0)
						{
							showDefeat();
						}
						
					}
				}
								
				if(ship[i].health <= 0)
				{
					
					playerScore = playerScore + 1;
					//screenShakeDuration = 15;
							
					exp[exp.length] = new explosion(ship[i].x+16,ship[i].y+16,"exp");
					
					if(ship[i].type=="boss")
						ship[i].health = 10
					else
						ship[i].health = 1;
					
					//if the "ship" is a flesh and blood fan, pop them
					//and leave a nice blood decal on the ground
					if(ship[i].type=="fan")
					{
						bloodX[bloodX.length] = ship[i].x-16;
						bloodY[bloodY.length] = ship[i].y-16;
						bloodID[bloodID.length] = Math.floor(Math.random() * bloodDecal.length);
					}
					
					respawnShip(i);
					
					
					enemiesLeft--;
					
					if(ship.length > enemiesLeft)
						ship.splice(i,1);
					
					if(enemiesLeft<=0)
						showWin();
					
				}
				else if((ship[i].health == 5000) && (playerHealth > 0))
				{
					enemiesLeft--;
					
					if(ship[i].type=="boss")
						ship[i].health = 10
					else
						ship[i].health = 1;
						
					if(ship.length > enemiesLeft)
						ship.splice(i,1);
					if(enemiesLeft<=0)
						showWin();
				}
			
			}
		}
	
	}
	
	function update()
	{
		if(gameStarted)
		{
			handleShipMovement();
			handleTrainMovement();
		}
		
		if(screenShakeDuration>0)
		{
			screenShakeDuration--;
			preShake();
			drawAdjustedCamera();
			//drawCamera();
			postShake();
		}
		else
			drawAdjustedCamera();
			//drawCamera();
		
		handleGameLogic();
		
		requestAnimationFrame(update);
	}
	
	function timedInterval()
	{
		
		if(document.getElementById("winScreen").style.display == "block")
		{
		
			if(document.getElementById("titleText").style.color == "orange")
				document.getElementById("titleText").style.color = "gold"
			else if (document.getElementById("titleText").style.color == "gold")
				document.getElementById("titleText").style.color = "lime"
			else if (document.getElementById("titleText").style.color == "lime")
				document.getElementById("titleText").style.color = "aqua"
			else if (document.getElementById("titleText").style.color == "aqua")
				document.getElementById("titleText").style.color = "violet"	
			else if (document.getElementById("titleText").style.color == "violet")
				document.getElementById("titleText").style.color = "red"
			else if (document.getElementById("titleText").style.color == "red")
				document.getElementById("titleText").style.color = "orange";
		}
		
		else if(document.getElementById("loseScreen").style.display == "block")
		{
			document.getElementById("titleText").style.color = "red";
			//explodeSomething(30+ Math.floor(Math.random() * (boundingWidth-80))+boundingX,50+Math.floor(Math.random() * (boundingHeight-140))+boundingY,"boom");
		}
		
		if(gameStarted)
		{
			
			//give a slight delay after killing the last enemy of the wave 
			//so we can see their death throes before showing the win screen
			if(finalCountdown != 5000)
				finalCountdown--;
			if(finalCountdown <=0)
				showActualWin();
			
			if(waveMode)
			{
				if((enemiesLeft > ship.length) && (playerLevel >= 3))
				{
					if(chainActive==false)
					{
						chainActive = true;
						chainLength = 3;
						chainX =  30+ Math.floor(Math.random() * (boundingWidth-80))+boundingX;
						
					}
					
					if(chainActive)
					{
						chainLength--;
						if(chainLength==0)
							chainActive = false;
						
						if(playerLevel>=6)
							ship[ship.length] = new entity(0,0,"runner")
						else
							ship[ship.length] = new entity(0,0,"grunt");
						respawnShip(ship.length-1);
						
						ship[ship.length-1].rot = 90; //270
						ship[ship.length-1].x = chainX;
						ship[ship.length-1].y = 50;
						ship[ship.length-1].targetX = chainX;
						ship[ship.length-1].targetY = boundingHeight;
					}
					
				}
			}
			
			
		}
	}
	
	function TryPlay(s)
	{

		/*if ((s == "track1") || (s == "track2") || (s == "track3") || (s == "track4"))
		{

			if (musicOn)
				document.getElementById(s).play();

			currentTrack = s;
		}

		else */if (soundOn)
		{
			//if you want the same sound to reset it's look so it always plays, uncomment
			//document.getElementById(s).currentTime = 0;
			document.getElementById(s).play();
			
		}
	}
	
	window.addEventListener("load", function()
	{
		update();
	});
	
	window.setInterval(timedInterval, 50000 / 60);
	
	</script>
	
	<script src="rot.js"></script>
	
	<script type="text/javascript" src="core.js"></script>
	<script type="text/javascript" src="explosion_html5.js"></script>
	
	<!--
	<audio id="mayhem" preload="auto">
        <source src="audio/8-Bit-Mayhem.mp3" type="audio/mp3">
    </audio>
	-->
</body>

</html>
