<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <!-- This is a wide open CSP declaration. To lock this down for production, see below. -->
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline'; style-src 'self' 'unsafe-inline'; media-src *" />
    <!-- Good default declaration:
    * gap: is required only on iOS (when using UIWebView) and is needed for JS->native communication
    * https://ssl.gstatic.com is required only on Android and is needed for TalkBack to function properly
    * Disables use of eval() and inline scripts in order to mitigate risk of XSS vulnerabilities. To change this:
        * Enable inline JS: add 'unsafe-inline' to default-src
        * Enable eval(): add 'unsafe-eval' to default-src
    * Create your own at http://cspisawesome.com
    -->
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: 'unsafe-inline' https://ssl.gstatic.com; style-src 'self' 'unsafe-inline'; media-src *" /> -->

    <!--
	<link rel="stylesheet" type="text/css" href="css/index.css" />
    -->
	
	<title>Panic Train</title>
	
	<style type="text/css"> 
		
		/*trying something out for responsive web design, as with the meta tag above*/
		@-ms-viewport
		{
		  width: device-width;
		}
		
		@font-face {
		font-family: "ineptic";
		src: url(font/font_ineptic.otf) format("truetype");
		}
		
		body 
		{
			color: #E9E9E9;
			background-color: black;	
			font-family: "My Custom Font", Robota, Tahoma;
			font-size: 15px;
			/*background-image: url("images/black3.png");*/
		}
	
		.button2 
		{
			color: black;
			background-color: white;
			border: 1px solid white;
			padding: 2px 4px;
			text-align: center;
			text-decoration: none;
			display: inline-block;
			font-size: 18px;
			font-family: 'Abel', sans-serif;
			margin: 4px 2px;
			-webkit-transition-duration: 0.4s; /* Safari */
			transition-duration: 0.4s;
			cursor: pointer;
			height: 40px;
			width: 50px; /*50px*/
			border-radius: 4px;
		}
		
		.button2:hover 
		{
			color: black;
			background-color: orange;			
			border: 1px solid black;
		}
		
		.primaryCanvas 
		{
			/*box-sizing: border-box;*/
			
			/*background:#0e8e39;*/ 
			/*#000;*/
			position:absolute;
			top:10px; /*10px*/
			left: 10px; /*10px*/
			border: 0px solid rgba(0,255,0,.2);
			border-radius: 12px;
			z-index:2;
			/*background-image: radial-gradient(limegreen, darkgreen);*/ /*weird gradient bg*/
		}
				
		.titleText{
            color: peru;
            font-size: 50px;
			font-family: "ineptic", Verdana, Tahoma;
        } 
		
		.center
		{
			text-align:center;
			-webkit-border-radius: 0.75em;
			/*-moz-border-radius: 0.75em;*/
			border-radius:0.75em;			
			/*background-color:rgba(33, 33, 33, 0.6);*/
			color:#ffffff;
			padding:25px;
			
			margin: 0;
			position: absolute;
			top: 40%;
			left: 50%;
			transform: translate(-50%, -30%);
	
		}
		.adjustedCenter
		{
			box-sizing: border-box;
			text-align:center;
			-webkit-border-radius: 0.75em;
			/*-moz-border-radius: 0.75em;*/
			border-radius:0.75em;			
			/*background-color:rgba(33, 33, 33, 0.6);*/
			color:#ffffff;
			padding:10px; /*25px*/
		}
		
		.menuScreen
		{
			position: absolute;
			z-index:9;
			background:#232323;
			border: 0px solid orange;
			display: block;
			width: 250px; /**/
			/*height:800px;*/
			display: none;
		}
		
		@keyframes rainbow-text 
		{
		  0% {
			color: #e87d7d;
		  }
		  2% {
			color: #e88a7d;
		  }
		  4% {
			color: #e8977d;
		  }
		  6% {
			color: #e8a47d;
		  }
		  8% {
			color: #e8b07d;
		  }
		  10% {
			color: #e8bd7d;
		  }
		  12% {
			color: #e8ca7d;
		  }
		  14% {
			color: #e8d77d;
		  }
		  16% {
			color: #e8e47d;
		  }
		  18% {
			color: #dfe87d;
		  }
		  20% {
			color: #d3e87d;
		  }
		  22% {
			color: #c6e87d;
		  }
		  24% {
			color: #b9e87d;
		  }
		  26% {
			color: #ace87d;
		  }
		  28% {
			color: #9fe87d;
		  }
		  30% {
			color: #92e87d;
		  }
		  32% {
			color: #86e87d;
		  }
		  34% {
			color: #7de881;
		  }
		  36% {
			color: #7de88e;
		  }
		  38% {
			color: #7de89b;
		  }
		  40% {
			color: #7de8a8;
		  }
		  42% {
			color: #7de8b5;
		  }
		  44% {
			color: #7de8c1;
		  }
		  46% {
			color: #7de8ce;
		  }
		  48% {
			color: #7de8db;
		  }
		  50% {
			color: #7de8e8;
		  }
		  52% {
			color: #7ddbe8;
		  }
		  54% {
			color: #7dcee8;
		  }
		  56% {
			color: #7dc1e8;
		  }
		  58% {
			color: #7db5e8;
		  }
		  60% {
			color: #7da8e8;
		  }
		  62% {
			color: #7d9be8;
		  }
		  64% {
			color: #7d8ee8;
		  }
		  66% {
			color: #7d81e8;
		  }
		  68% {
			color: #867de8;
		  }
		  70% {
			color: #927de8;
		  }
		  72% {
			color: #9f7de8;
		  }
		  74% {
			color: #ac7de8;
		  }
		  76% {
			color: #b97de8;
		  }
		  78% {
			color: #c67de8;
		  }
		  80% {
			color: #d37de8;
		  }
		  82% {
			color: #df7de8;
		  }
		  84% {
			color: #e87de4;
		  }
		  86% {
			color: #e87dd7;
		  }
		  88% {
			color: #e87dca;
		  }
		  90% {
			color: #e87dbd;
		  }
		  92% {
			color: #e87db0;
		  }
		  94% {
			color: #e87da4;
		  }
		  96% {
			color: #e87d97;
		  }
		  98% {
			color: #e87d8a;
		  }
		  100% {
			color: #e87d7d;
		  }
		}
		.rainbow-text 
		{
		  animation: rainbow-text 1s infinite;
		}
		
	</style>
	
</head>

<body onload="startingSetup();" onkeyup="return playerKeyUp(event);">
   
   <!--
   <div class="app">
        
		<h1>Hello Shotgun Triangle</h1>
        <div id="deviceready" class="blink">
            <p class="event listening">Connecting to Device</p>
            <p class="event received">Device is Ready</p>
        </div>
			
    </div>
	-->
	
	<canvas id="primaryCanvas" class="primaryCanvas" onclick="canvasClick(event)"></canvas>
	
	<div id="menuScreen" class="menuScreen center">
		<span id="menuTitle" class="titleText rainbow-text" style="color:orange">PANIC TRAIN</span>
		<br />
		<img width="250px" src="images/TK/splash.jpg">
		<br />
		<span id="output" class="rainbow-text">No stops. No brakes. Only death.</span> <br />
		<br />
		<input type ="button" value ="START" style="width:245px;" onclick="continueGame();" class="button2"><br />
	</div>
	
	<div id="loseScreen" class="menuScreen center">
		<span class="titleText" style="color:red">GAME OVER</span>
		<br />
		<img width="250px" src="images/TK/fail.jpg"> 
		<br />
		<span id="output_fail">The train has ground to a halt.</span> <br />
		<br />
		<span id="score_fail">SCORE: 0</span> <br />
		<span id="level_fail">LEVEL: 0</span> <br />
		<br />
		<input type ="button" value ="RESTART" style="width:245px;" onclick="continueGame();" class="button2"><br />
	</div>
	
	<div id="winScreen" class="menuScreen center">
		<span class="titleText" id="titleText" style="color:orange">V I C T O R Y</span>
		<br />
		<img width="250px" src="images/TK/win.jpg">
		<br />
		<span id="output_win">Choo choo motherfuckers.</span> <br />
		<br />
		<span id="score_win">SCORE: 0</span> <br />
		<span id="level_win">LEVEL: 0</span> <br />
		<br />
		<input type ="button" value ="CONTINUE" style="width:245px;" onclick="continueGame();" class="button2"><br />
	</div>
	
    <script type="text/javascript" src="cordova.js"></script>
    <script type="text/javascript" src="js/index.js"></script>
    <script type="text/javascript">
        app.initialize();
    </script>
	
	<script>
	
	//nX = 0;
	//nY = 0;
	
	/*
	pressing keys to lay tracks
	Concentric ring explosions [think shelling]
	Fans/zombies rushing the train
	upgrades
	
	*/
	
	function tile(pForeground, pBackground, pHealth, pSolid)
	{
		this.f = pForeground;
		this.b = pBackground;
		this.detected = "na";
		this.health = pHealth;
		this.solid = pSolid;
		this.light = 1;;
		this.charCol = "white";
		this.frame = 0;
		this.bgFrame = 0;
		this.special = 0;
		this.x = 0;
		this.y = 0;
	}
		
	function heavenlyBody(pX,pY)
	{
		this.x = pX;
		this.y = pY;
		this.dx = 0;
		this.dy = 0;
		this.distance = distanceArray[Math.floor(Math.random() * distanceArray.length)];
		this.radius = Math.floor(Math.random() * 2)+1;
		
		if(Math.floor(Math.random() * 10)>9)
			this.radius = 3;
		
		//if(Math.floor(Math.random() * 10)>8)
		//	this.type = "customStar"
		//else 
		this.type = "star";
		this.colour = greyShades[Math.floor(Math.random() * greyShades.length)];
		
		if(Math.floor(Math.random() * 10)>7)
			this.colour = colorArray[Math.floor(Math.random() * colorArray.length)];
		
		var rX = Math.floor(Math.random() * 3000)-1500;
		
	}
	
	function entity(pX, pY, pType)
	{
		this.x = pX;
		this.y = pY;
		this.rot = 270;
		this.dx = 0;
		this.dy = 0;
		this.ax = 0;
		this.ay = 0;
		this.speed = 0; //8
		this.maxSpeed = 2; //5
		this.xSpeed = 6; //8
		this.jumpPower = 8
		this.hasGravity = true;
		this.health = 1;
		this.energy = 10;
		
		this.targetX = 0;
		this.targetY = 0;
		
		this.radius = 32;
		
		this.accelerationPower = 0.05; //0.05 //0.2
		this.turningSpeed = 5;
		
		this.image = new Image();
		this.image.src = "images/ninja_0.png";
		//this.image.src = "images/small/sab_complete.png";
		this.frame = 1;
		this.frameMax = 6;
		
		this.team = "enemy";
		this.type = pType;
		
		//stuff just for the player
		this.wallSlide = false;
		this.jumpStage = 0;
		
		
		//stuff for monsters/projectiles
		this.moveTimer = 0;
		this.moveTimerMax = 3;
		this.direction = "left";
		
		this.specialTimer = 12;
		this.specialTimerMax = 12;
		
		this.weapon = "blaster";
		this.missiles = 0;
		
		this.sparkTimer = 20;
		this.energyRegenTimer = 0;
		this.energyRegenTimerMax = 10;
		
		if(this.type=="spy")
		{
			this.health = 1;
			this.maxSpeed = 0;
			this.image.src = "images/ninja_3.png";
		}
		else if(this.type=="runner") 
		{
			this.health = 1;
			this.maxSpeed = 4;
			this.image.src = "images/ninja_0.png";
		}
		else if(this.type=="grunt") 
		{
			this.health = 1;
			this.maxSpeed = 2;
			this.image.src = "images/turtle_0.png";
		}
		else if(this.type=="boss") 
		{
			this.health = 10;
			this.maxSpeed = 1;
			this.image.src = "images/green.png";
		}
		
		else if(this.type=="slider") 
		{
			this.team = "enemy";
			this.image.src = "images/small/sab_1.png";
			this.accelerationPower = 1; //0.05 //0.2
			this.turningSpeed = 5;
			this.maxSpeed = 4;
			this.turningSpeed = 5;
			this.weapon = "particle";
		}
		else if(this.type=="station") 
		{
			this.image.src = "images/small/ss2.png"; //ninja_1 ss2
			this.team = "player";
			this.accelerationPower = 0;
			this.maxSpeed = 0;
			this.turningSpeed = 0.1; //0.1
			this.health = 50;
			this.radius = 175;
			//alert(this.image.src);
			this.weapon = "none";
		}
		else if(this.type=="fan") 
		{
			var r = Math.floor(Math.random() * 9)+1;
			this.health = 1;
			this.maxSpeed = 1; //2
			this.image.src = "images/fan"+r+".png";
		}
		else if(this.type=="trainFront") 
		{
			this.team = "player";
			this.image.src = "images/expTrainFront2.png";
			this.health = 5;
			this.radius = 32;
		}
		else if(this.type=="trainWood") 
		{
			this.team = "player";
			this.image.src = "images/expTrainWood.png";
			this.health = 5;
			this.radius = 32;
		}
		else if(this.type=="trainGoods") 
		{
			this.team = "player";
			this.image.src = "images/expTrainGoods.png";
			this.health = 5;
			this.radius = 32;
		}
		else if(this.type=="trainBack") 
		{
			this.team = "player";
			this.image.src = "images/expTrainBack2.png";
			this.health = 5;
			this.radius = 32;
		}
		
		this.maxHealth = this.health;
		this.maxEnergy = this.energy;
	
	}
	
	function explosion(pX,pY,t)
	{
		this.frame = 0;
		//this.img = new Image();
		//this.img.src = "images/"+t+"0.png";
		this.x = pX;
		this.y = pY;
		this.type = t;
		this.canvas = "primaryCanvas";
	}
	
	mapWidth = 10; //33 //20
	mapHeight = 10
	
	map = [];
	for (x = 0; x < mapWidth; x++)
	{
		map[x] = [];
		for (y = 0; y < mapHeight; y++)
		{
			map[x][y] = new tile(".", "d", "500", true);
		}
	}
	tileSize = 32;
	
	bloodDecal = [];
	for (var i = 0; i < 30; i++)
	{
		bloodDecal[i] = new Image();
		bloodDecal[i].src = "images/blood_red"+i+".png";
	}
	
	panel = new Image();
	panel.src = "images/panel.png";
	
	
	trainTurret = new Image();
	trainTurret.src = "images/trainTurret.png";
	
	expTrainFront = new Image();
	expTrainGoods = new Image();
	expTrainWood = new Image();
	expTrainBack = new Image();
	expTrainFront.src = "images/expTrainFront2.png";
	expTrainGoods.src = "images/expTrainGoods.png";
	expTrainWood.src = "images/expTrainWood.png";
	expTrainBack.src = "images/expTrainBack2.png";
	
	greenSquare = new Image();
	greenSquare.src = "images/green.png";
	
	playerHealth = 3;
	playerLevel = 1;
	
	gameStarted = false;
	
	explosionSheet = new Image();
	explosionSheet.src = "images/explosion_total.png";
	
	soundOn = true;
	
	heartEmpty = new Image();
	heartEmpty.src = "images/heart_empty.png";
	heartFull = new Image();
	heartFull.src = "images/heart.png";
	
//	nebulaA = new Image();
//	nebulaA.src = "images/neb1.png";
	
	ninja = new Image();
	ninja.src = "images/ninja_3.png";
	
	dirt = new Image();
	dirt.src = "images/dirt.png";
	
	dirtB = new Image();
	dirtB.src = "images/dirt1.png";
	
	dirtC = new Image();
	dirtC.src = "images/dirt2.png";
	
	stone = new Image();
	stone.src = "images/stone1.png";
	
	rail = new Image();
	rail.src = "images/rail.png";
	railH = new Image();
	railH.src = "images/rail_h.png";
	railBottomLeft = new Image;
	railBottomRight = new Image;
	railBottomLeft.src = "images/rail_bottomleft.png";
	railBottomRight.src = "images/rail_bottomright.png";
	railTopLeft = new Image;
	railTopRight = new Image;
	railTopLeft.src = "images/rail_topleft.png";
	railTopRight.src = "images/rail_topright.png";
	
	ship = [];
	
	touchText = "";
	
	//starScape = new Image();
	//starFog = new Image();
	//starScape.src = "images/newStars2.png";
	//starFog.src = "images/fog2.png"; // starFog
	
	star = [];
	
	greyShades = 
	[
	"#E0E0E0",
	"#D3D3D3",
	"#C0C0C0",
	"#B8B8B8",
	"#A9A9A9",
	"#A0A0A0",
	"#909090",
	"#696969",
	"#585858",
	"#484848",
	"#282828",
	//"yellow",
	//"darkgreen",
		//"dodgerblue",
		//"darkred"//,
	//"nebula"
	];
	
	var colorArray = ['#FF6633', '#FFB399', '#FF33FF', '#FFFF99', '#00B3E6', 
		'#E6B333', '#3366E6', '#999966', '#99FF99', '#B34D4D',
		'#80B300', '#809900', '#E6B3B3', '#6680B3', '#66991A', 
		'#FF99E6', '#CCFF1A', '#FF1A66', '#E6331A', '#33FFCC',
		'#66994D', '#B366CC', '#4D8000', '#B33300', '#CC80CC', 
		'#66664D', '#991AFF', '#E666FF', '#4DB3FF', '#1AB399',
		'#E666B3', '#33991A', '#CC9999', '#B3B31A', '#00E680', 
		'#4D8066', '#809980', '#E6FF80', '#1AFF33', '#999933',
		'#FF3380', '#CCCC00', '#66E64D', '#4D80CC', '#9900B3', 
		'#E64D66', '#4DB380', '#FF4D4D', '#99E6E6', '#6666FF'];
	
	distanceArray = [0.10,0.25,0.5,0.75,1,1.25];
	
	keyArray = 	[
					['Q','VK_Q'],
					['P','VK_P'],
					['E','VK_E'],
					['R','VK_R']
				];
		
	function getDist(x, y, x2, y2)
	{
		x = x2 - x;
		y = y2 - y;
		return Math.floor(Math.sqrt(x * x + y * y));
	}
	
	function wrapText(ctx, text, x, y, maxWidth, lineHeight) 
	{
		var words = text.split(' ');
        var line = '';

        for(var n = 0; n < words.length; n++) 
		{
			var testLine = line + words[n] + ' ';
			var metrics = ctx.measureText(testLine);
			var testWidth = metrics.width;
			if (testWidth > maxWidth && n > 0) 
			{
				ctx.fillText(line, x, y);
				line = words[n] + ' ';
				y += lineHeight;
			}
			else 
			{
				line = testLine;
			}
        }
        ctx.fillText(line, x, y);
    }
	
	function explodeSomething(x,y,type)
	{
		if(type=="spark")
		{
			var explosion_colors = ['#FFFF00','#FFD700'];
			var explosion = new ExplosionClass(x, y, explosion_colors,3); //3
		}
		else if(type=="ting")
		{
			var explosion_colors = ['blue','aqua','teal'];
			var explosion = new ExplosionClass(x, y, explosion_colors,4);
		}
		else
		{
			var explosion_colors = ['orange','red','FireBrick','darkorange'];
			var explosion = new ExplosionClass(x, y, explosion_colors,8);
		}
		/*
		if(type=="ship")
		{
			var explosion_colors = ['orange','red','FireBrick','darkorange'];
			var explosion = new ExplosionClass(ship[i].x+16, ship[i].y+16, explosion_colors,8);
		}
		else if(type=="projectile")
		{
			
		}
		else if(type=="spark")
		{
			var explosion_colors = ['#FFFF00','#FFD700'];
			var explosion = new ExplosionClass(pro[i].x, pro[i].y, explosion_colors,3);
		}
		else if(type=="heal")
		{
			var explosion_colors = ['blue','dodgerblue','aqua'];
			var explosion = new ExplosionClass(player.x, player.y, explosion_colors,3);
		}
		*/
		explosion.ctx = context;
		explosions.push(explosion);
		
	}
	
	function GetYDiff()
	{
		//alert(map[0][1].y);
		
		//var currY = map[0][0].y;
		
		
		
	}
	
	function layTrack(p)
	{
		
		GetYDiff();
		//RAAAAAAAAAAAAAAFE
		//do your shield wolf magic here
		//fix shit up
		//add in variable tracks, direction changes etc.
				
		//we should probably add in tracks that are combined with dangers here
		//otherwise there would only be left, straight, right? (for tracks that work)
				
		lastRailY = lastRailY - 1;
		//alert(mapHeight);
		if(lastRailY<0)
			lastRailY = mapHeight-1;
			
		//map[lastRailX][lastRailY].b = "r";
		map[lastRailX][lastRailY].b = railOption[p];
		lastRailType = railOption[p];
		
		//assign a random key to be pressed
		keyArray = 	[
					['A','VK_A'],
					['B','VK_B'],
					['C','VK_C'],
					['D','VK_D'],
					['E','VK_E'],
					['F','VK_F'],
					['G','VK_G'],
					['H','VK_H'],
					['I','VK_I'],
					['J','VK_J'],
					['K','VK_K'],
					['L','VK_L'],
					['M','VK_M'],
					['N','VK_N'],
					['O','VK_O'],
					['P','VK_P'],
					['Q','VK_Q'],
					['R','VK_R'],
					['S','VK_S'],
					['T','VK_T'],
					['U','VK_U'],
					['V','VK_V'],
					['W','VK_W'],
					['Y','VK_Y'],
					['X','VK_X'],
					['Z','VK_Z']
					];
		
		for(var i = 0; i < 24; i++)
		{
			var randomKey = Math.floor(Math.random() * keyArray.length);
			keyArray.splice(randomKey,1);
		}
		
		//railRep[0] = railBottomRight;
		//railRep[1] = railBottomLeft;
		//railOption[0] = "left";
		//railOption[1] = "left";
		//select an appropriate matching rail tile
		
		railRep = [];
		railOption = [];
		for(var i = 0; i < 2; i++)
		{
			railOption[i] = "up"; //easy mode
			/*
			var r = Math.floor(Math.random()*3);
			if(lastRailType=="up")
			{
				if(r==0)
					railOption[i] = "up"
				else if(r==1)
					railOption[i] = "topleft"
				else if(r==2)
					railOption[i] = "topright"
			}
			else if(lastRailType=="down")
			{
				if(r==0)
					railOption[i] = "down"
				else if(r==1)
					railOption[i] = "bottomleft"
				else if(r==2)
					railOption[i] = "bottomright"
			}
			else if(lastRailType=="left")
			{
				if(r==0)
					railOption[i] = "left"
				else if(r==1)
					railOption[i] = "topleft"
				else if(r==2)
					railOption[i] = "bottomleft"
			}
			else if(lastRailType=="right")
			{
				if(r==0)
					railOption[i] = "right"
				else if(r==1)
					railOption[i] = "topright"
				else if(r==2)
					railOption[i] = "bottomright"
			}
			else if(lastRailType=="topleft")
			{
				railOption[i] = "right"
			}
			else if(lastRailType=="topright")
			{
				railOption[i] = "left"
			}
			else if(lastRailType=="bottomleft")
			{
				railOption[i] = "right"
			}
			else if(lastRailType=="bottomright")
			{
				railOption[i] = "left"
			}
			else // still need the other 4 types
			{
				alert("heywhat");
			}
			*/
			if((railOption[i]=="left") || (railOption[i]=="right"))
				railRep[i] = railH
			else if((railOption[i]=="up") || (railOption[i]=="down"))
				railRep[i] = rail
			else if(railOption[i]=="topleft")
				railRep[i] = railTopLeft
			else if(railOption[i]=="topright")
				railRep[i] = railTopRight
			else if(railOption[i]=="bottomleft")
				railRep[i] = railBottomLeft
			else if(railOption[i]=="bottomright")
				railRep[i] = railBottomRight
			else
			{
				alert("what");
			}
			
		}
		
	}
	
	function playerKeyUp(e)
	{
		var keynum;

		if (window.event) // IE                    
		{
			keynum = e.keyCode;
		}
		else if (e.which) // Netscape/Firefox/Opera
		{
			keynum = e.which;
		}

		var keyPressed = "?";
		for(var name in ROT){
			if(ROT[name] == keynum && name.indexOf("VK_") == 0) {keyPressed=name;}
		}

		if(keyPressed=="VK_LEFT")
		{
			//do nothing
		}
				
		else if(keyPressed==keyArray[0][1])
			layTrack(0)
		else if(keyPressed==keyArray[1][1])
			layTrack(1);
		
		//else if(keyPressed=="VK_Q")
		//{
		//	layTrack(1);
		//}
				
	}
	
	function targetShip(x,y)
	{
		if(gameStarted)
		{
		
			
		
			var lethalHit = true;		
			var targetHit = false;
			for (var i = 0; i < ship.length; i++)
			{
				if(getDist(ship[i].x+16,ship[i].y+16,x,y)<32) 
				{
					targetHit = true;
					ship[i].health = ship[i].health - 1;
					
					if(ship[i].health > 0)
						lethalHit = false;
				}
							
			}
			
			if(targetHit==false)
			{
				explodeSomething(x,y,"spark");
			}
			else if((targetHit==true) && (lethalHit==false))
			{
				explodeSomething(x,y,"ting");
			}
				
			// If there's exactly one finger inside this element
			//  if (event.targetTouches.length == 1) 
			//  {
			//	var touch = event.targetTouches[0];
				//touchText = touch.pageX + 'px; ' + touch.pageY + 'px';
				// Place element where the finger is
				//obj.style.left = touch.pageX + 'px';
				//obj.style.top = touch.pageY + 'px';
			  //}
		  
		}
	}
	
	
	
	function respawnShip(p)
	{
		
		ship[p].x = 30+ Math.floor(Math.random() * (boundingWidth-80))+boundingX;
		ship[p].y = 50;
		if(ship[p].type=="spy")
			ship[p].y = 50+Math.floor(Math.random() * (boundingHeight-140))+boundingY;
		ship[p].targetX = Math.floor(Math.random() * boundingWidth)+boundingX;
		ship[p].targetY = boundingHeight;
		
		if(ship[p].type=="fan")
		{
			var r = Math.floor(Math.random() * 9)+1;
			ship[p].image.src = "images/fan"+r+".png";
			var r = Math.floor(Math.random() * 3);
			if(r==0)
			{
				ship[p].targetX = comp[0].x;
				ship[p].targetY = comp[0].y;
			}
			
		}
		
	}
	
	var obj = document.getElementById('primaryCanvas');
	obj.addEventListener('touchmove', function(event) 
	{
		if(gameStarted)
		{
			var z = 0; //limit touches to the 1st finger 
			//for (var z = 0; z < event.targetTouches.length; z++)
			{
				swipeLength++;
				if(swipeLength < 20)
				{
					var touch = event.targetTouches[z];
					var x = touch.pageX;
					var y = touch.pageY;
					targetShip(x,y);
				}
			}
			
			//superpower test
			if((event.targetTouches.length==2) && (swipeLength > 15) && (swipeLength < 20))
			{
				swipeLength = 100;
				for (var i = 0; i < ship.length; i++)
				{
					ship[i].health = 0;
					explodeSomething(ship[i].x,ship[i].y,"boom");
				}
			}
			
		}
		
	}, false);
			
	obj.addEventListener('touchstart', function(event) 
	{
		
		//if there is only one finger starting to touch, reset the swipe length 
		//counter as we are starting a new swipe
		if(event.targetTouches.length==1)
			swipeLength = 0;
		
		touchText = "";
		//touchText = "touches: " + event.targetTouches.length;
		
		if(gameStarted)
		{
			for (var z = 0; z < event.targetTouches.length; z++)
			{
				var touch = event.targetTouches[z];
				var x = touch.pageX;
				var y = touch.pageY;
				targetShip(x,y);
				
				////
				//maybe we are trying to hit a panel and not a ship, whooops
				for (var i = 0; i < panelX.length; i++)
				{
					if(getDist(panelX[i]+25,panelY[i]+25,x,y)<40)
						layTrack(i);
				}
				/////
				
			}
		}
		
	}, false);
	
	obj.addEventListener('touchend', function(event) 
	{
		/*
		if(gameStarted)
		{
			
			for (var z = 0; z < event.targetTouches.length; z++)
			{
								
				var touch = event.targetTouches[z];
				var x = touch.pageX;
				var y = touch.pageY;
				targetShip(x,y);
			}
		}
		*/
		
	}, false);
	
	function canvasClick(event)
	{
		if(gameStarted)
		{
			var x = event.clientX;
			var y = event.clientY;
			targetShip(x,y);
		}
	}
	
	function continueGame()
	{
		gameStarted = true;
		introScreenDone = true;
		document.getElementById('menuScreen').style.display = "none";
		document.getElementById('winScreen').style.display = "none";
		document.getElementById('loseScreen').style.display = "none";
		//globalTimer = 60;
	}
	
	function showDefeat()
	{
		gameStarted = false;
		document.getElementById('score_fail').innerHTML = "SCORE: " + playerScore;
		document.getElementById('level_fail').innerHTML = "LEVEL: " + playerLevel;
		playerScore = 0;
		playerLevel = 1;
		playerHealth = 3;
		hello();
		document.getElementById('loseScreen').style.display = "block";
	}
	
	function showActualWin()
	{
		gameStarted = false;
		document.getElementById('score_win').innerHTML = "SCORE: " + playerScore;
		document.getElementById('level_win').innerHTML = "LEVEL: " + playerLevel;
		playerLevel++;
		hello();
		document.getElementById('winScreen').style.display = "block";
	}
	
	function showWin()
	{
		finalCountdown = 1;
	}
	
	function startingSetup()
	{
		
		//TryPlay("mayhem");
		gameStarted = false;
		introScreenDone = false;
		waveMode = false;
		document.getElementById('menuScreen').style.display = "block";
		document.getElementById('loseScreen').style.display = "none";
		document.getElementById('winScreen').style.display = "none";
		
		var w = window,
		d = document,
		e = d.documentElement,
		g = d.getElementsByTagName('body')[0],
		x = w.innerWidth || e.clientWidth || g.clientWidth,
		y = w.innerHeight|| e.clientHeight|| g.clientHeight;
		//alert(x + ' × ' + y);
				
		canvas = document.getElementById("primaryCanvas");
		canvas.width = x-50; //1920
		canvas.height = y-30; //900
		
		boundingX = 0;
		boundingY = 0;
		boundingWidth = x-30;
		boundingHeight = y-30;
		
		context = document.getElementById('primaryCanvas').getContext('2d');
		
		lastRailX = 4;
		lastRailY = -10;
		lastRailType = "up";
		railRep = [];
		railOption = [];
		railOption[0] = "up";
		railOption[1] = "up";
		railRep[0] = rail;
		railRep[1] = rail;
		yTravelled = 0;
		
		panelX = [];
		panelY = [];
		panelX[0] = boundingX+30;
		panelY[0] = boundingHeight-80-48;
		panelX[1] = boundingWidth-100;
		panelY[1] = boundingHeight-80-48;
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[0], panelY[0]);
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[0], panelX[0]+8, panelY[0]+9);
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[1], panelY[1]);
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[1],panelX[1]+8, panelY[1]+9);
			
		bloodX = []
		bloodY = []
		bloodID = [];
		
		mapWidth = Math.floor(boundingWidth/tileSize); //33 //20
		mapHeight = Math.floor(boundingHeight/tileSize)+3;
		
		map = [];
		for (x = 0; x < mapWidth; x++)
		{
			map[x] = [];
			for (y = 0; y < mapHeight; y++)
			{
				map[x][y] = new tile(".", "d", "500", true);
				map[x][y].x = x*tileSize;
				map[x][y].y = y*tileSize;
				var r = Math.floor(Math.random()*3); //4
				if(r==0)
					map[x][y].f = "a"
				else if(r==1)
					map[x][y].f = "b"
				else if(r==2)
					map[x][y].f = "c"
				else if(r==3)
					map[x][y].f = "d";
				
			}
		}
		
		x = lastRailX;
		for (y = 0; y < mapHeight; y++)
		{
			map[x][y].b = "up";
		}
		
		//nX = Math.floor(Math.random() * boundingWidth)+boundingX;;
		//nY = Math.floor(Math.random() * boundingHeight)+boundingY;;
		playerScore = 0;
		globalTimer = 60;
		enemiesLeft = 20;
		
		distanceTravelled = 0;
		
		shipDY = 0;
		shipDX = 0;
		shipX = 10;
		shipY = 10;
		starX = 0;
		starY = 0;
		fogX = 0;
		fogY = 0;
		
		screenShakeDuration = 0;
		
		finalCountdown = 5000;
		
		lightningCounter = 0;
		starTimer = 0;
		starX = 0;
		starX_right = 1920;
		fogX = 0;
		fogX_right = 1920;
		backX = 3000;
		
		comp = [];
		player = new entity(528,488,"player");
		player.dx = 0;
		player.dy = -0.5; //-1
		
		star = [];
		for (var i = 0; i < 270; i++) //500 //270
		{
			var rX = Math.floor(Math.random() * boundingWidth)+boundingX;
			var rY = Math.floor(Math.random() * boundingHeight)+boundingY;
			star[star.length] = new heavenlyBody(rX,rY);
		}
		
		playerHealth = 3;
		hello();
		
		grindTimer = 0;
		
		//GetYDiff();
		
	}
	
	function hello()
	{
		
		gameStarted = false;
		finalCountdown = 5000;
		
		chainActive = false;
		chainLength = 0;
		chainX = 0;
		
		swipeLength = 0;
		
		exp = [];
		ship = [];
		
		globalTimer = 60;
		
		comp = [];
		comp[0] = new entity((lastRailX*tileSize)+16,32*8,"trainFront");
		
		//comp[0] = new entity((lastRailX*tileSize)+16,(boundingHeight-(32*6))+(32*0),"trainFront");
		//comp[1] = new entity((lastRailX*tileSize)+16,(boundingHeight-(32*6))+(32*1),"trainWood");
		//comp[2] = new entity((lastRailX*tileSize)+16,(boundingHeight-(32*6))+(32*2),"trainGoods");
		//comp[3] = new entity((lastRailX*tileSize)+16,(boundingHeight-(32*6))+(32*3),"trainBack");
		
		bloodX = [];
		bloodY = [];
		bloodID = [];
		
		if(playerLevel<=1)
		{
			globalTimer = 10;
			enemiesLeft = 20; // 10;
			ship[0] = new entity(0,0,"fan");
			ship[1] = new entity(0,0,"fan");
			ship[2] = new entity(0,0,"fan");
			//ship[0] = new entity(0,0,"spy");
			//ship[1] = new entity(0,0,"spy");
			//ship[2] = new entity(0,0,"spy");
			//ship[3] = new entity(0,0,"grunt");
		}
		
		else if(playerLevel==2)
		{
			globalTimer = 20;
			enemiesLeft = 20; //20;
			ship[0] = new entity(0,0,"fan");
			ship[1] = new entity(0,0,"fan");
			ship[2] = new entity(0,0,"fan");
		}
		
		else if(playerLevel==3)
		{
			globalTimer = 30;
			enemiesLeft = 30;
			waveMode = true;
			//ship[0] = new entity(0,0,"grunt");
			//ship[1] = new entity(0,0,"grunt");
			//ship[2] = new entity(0,0,"grunt");
			//ship[3] = new entity(0,0,"grunt");
		}
		
		else if(playerLevel==4)
		{
			globalTimer = 40;
			enemiesLeft = 40;
			waveMode = false;
			ship[0] = new entity(0,0,"fan");
			ship[1] = new entity(0,0,"fan");
			ship[2] = new entity(0,0,"fan");
		}
		
		else if(playerLevel==5)
		{
			globalTimer = 50;
			enemiesLeft = 50;
			ship[0] = new entity(0,0,"fan");
			ship[1] = new entity(0,0,"fan");
			ship[2] = new entity(0,0,"fan");
		}
		
		else
		{
			globalTimer = 60;
			enemiesLeft = 60;
			//waveMode = true;
			ship[0] = new entity(0,0,"fan");
			ship[1] = new entity(0,0,"fan");
			ship[2] = new entity(0,0,"fan");
		}
		
		//ship = [];
		//for (var i = 0; i < 100; i++)
		//{
		//	ship[ship.length] = new entity(10,10,"spy");
		//}
		
		for (var i = 0; i < ship.length; i++)
		{
			respawnShip(i);
		}
		
		//playerScore = 0;
		
		
		
		screenShakeDuration = 0;
		
		
		/*
		player = new entity(528,488,"player");
		player.dx = 0;
		player.dy = -1;
		
		star = [];
		for (var i = 0; i < 270; i++) //500 //270
		{
			var rX = Math.floor(Math.random() * boundingWidth)+boundingX;
			var rY = Math.floor(Math.random() * boundingHeight)+boundingY;
			star[star.length] = new heavenlyBody(rX,rY);
		}
		*/
		
		
	lastRailX = 4;
		lastRailY = -10;
		lastRailType = "up";
		railRep = [];
		railOption = [];
		railOption[0] = "up";
		railOption[1] = "up";
		railRep[0] = rail;
		railRep[1] = rail;
		yTravelled = 0;
		
		panelX = [];
		panelY = [];
		panelX[0] = boundingX+30;
		panelY[0] = boundingHeight-80-48;
		panelX[1] = boundingWidth-100;
		panelY[1] = boundingHeight-80-48;
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[0], panelY[0]);
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[0], panelX[0]+8, panelY[0]+9);
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[1], panelY[1]);
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[1],panelX[1]+8, panelY[1]+9);
			
		bloodX = []
		bloodY = []
		bloodID = [];
		
		mapWidth = Math.floor(boundingWidth/tileSize); //33 //20
		mapHeight = Math.floor(boundingHeight/tileSize)+3;
		
		map = [];
		for (x = 0; x < mapWidth; x++)
		{
			map[x] = [];
			for (y = 0; y < mapHeight; y++)
			{
				map[x][y] = new tile(".", "d", "500", true);
				map[x][y].x = x*tileSize;
				map[x][y].y = y*tileSize;
				var r = Math.floor(Math.random()*3); //4
				if(r==0)
					map[x][y].f = "a"
				else if(r==1)
					map[x][y].f = "b"
				else if(r==2)
					map[x][y].f = "c"
				else if(r==3)
					map[x][y].f = "d";
				
			}
		}
		
		x = lastRailX;
		for (y = 0; y < mapHeight; y++)
		{
			map[x][y].b = "up";
		}
		
		
	}
	
	function drawStars()
	{
		//do literally nothing 
		//drawR(scoutShip[engineFrame],player.x-cameraX,player.y-cameraY,player.rot+90,"primaryCanvas")
		
		for (var i = 0; i < star.length; i++)
		{
			//context.drawImage(turretImage,star[i].x-cameraX, star[i].y-cameraY);
			
			//new way, move the whole universe.
			star[i].dx = player.dx*star[i].distance*-1;
			star[i].dy = player.dy*star[i].distance*-1;
			star[i].x = star[i].x + star[i].dx;
			star[i].y = star[i].y + star[i].dy;
			
			//if((introScreenDone==true) && (gameStarted==false))
			if(document.getElementById("winScreen").style.display == "block")
				context.fillStyle = document.getElementById("titleText").style.color
			else if(document.getElementById("loseScreen").style.display == "block")
				context.fillStyle = "darkred";
			else
				context.fillStyle = star[i].colour;
				
			//context.fillRect(star[i].x, star[i].y,2,2);
			//if(variableStarSize)
			//{
				//if(star[i].type=="star")
					context.fillRect(star[i].x, star[i].y,star[i].radius,star[i].radius);
				//else
				//	context.drawImage(customStar[star[i].radius],star[i].x, star[i].y);
				
				
				//if(star[i].radius>=3)
				//	context.globalAlpha = 0.3;
				//context.fillRect(star[i].x, star[i].y,star[i].radius,star[i].radius);
				//context.globalAlpha = 1;
				//customStar
				
			//}
			//else
			//	context.fillRect(star[i].x, star[i].y,2,2);
			
			//if(star[i].colour=="nebula")
			//	context.drawImage(nebulaA,star[i].x-cameraX, star[i].y-cameraY);
			
			
			//}
			//old way, draw stars where they are
			//context.fillRect(star[i].x-cameraX, star[i].y-cameraY,2,2);
			
			
			//context.strokeStyle = star[i].colour;
			
			//context.beginPath();
            //context.arc(star[i].x-cameraX, star[i].y-cameraY, star[i].radius, 0, 2 * Math.PI, false);
            //context.fill();
            //context.stroke();
			
		}
		
		//reposition stars that leave the bounding box
		for (var i = star.length-1; i >= 0; i--)
		{
			//if	(
			//		(star[i].x<boundingX) || (star[i].y<boundingY) ||
			//		(star[i].x>boundingX+boundingWidth) || (star[i].y>boundingY+boundingHeight)
			//	)
			//	star[i].colour = "limegreen";
				
			if(star[i].x<boundingX)
				star[i].x = boundingX+boundingWidth;
			else if(star[i].x>boundingX+boundingWidth)
				star[i].x = boundingX;
			if(star[i].y<boundingY)
				star[i].y = boundingY+boundingHeight;
			else if(star[i].y>boundingY+boundingHeight)
			{
				star[i].y = boundingY;
				star[i].colour = greyShades[Math.floor(Math.random() * greyShades.length)];
				if(Math.floor(Math.random() * 10)>7)
					star[i].colour  = colorArray[Math.floor(Math.random() * colorArray.length)];
			}
		}
		
		//draw planets and nebulae
		/*
		for (var i = 0; i < planet.length; i++)
		{
			if(planet[i].type == "planet_redblue")
				context.drawImage(planetImg[0],planet[i].x-cameraX,planet[i].y-cameraY)
			else if (planet[i].type == "planet_blue")
				context.drawImage(planetImg[1],planet[i].x-cameraX,planet[i].y-cameraY)
			else if (planet[i].type == "moon_red")
				context.drawImage(planetImg[2],planet[i].x-cameraX,planet[i].y-cameraY);
				
			if(planet[i].type == "nebulaA")
				context.drawImage(nebulaA,planet[i].x-cameraX,planet[i].y-cameraY)
			else if (planet[i].type == "nebulaB")
				context.drawImage(nebulaB,planet[i].x-cameraX,planet[i].y-cameraY)
			else if (planet[i].type == "nebulaC")
				context.drawImage(nebulaC,planet[i].x-cameraX,planet[i].y-cameraY);
		}
		*/
		
	}
	
	function old_drawStars()
	{
	
		
		starX = 0;
		
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starScape, starX, 0);
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starScape, starX_right, 0);
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starFog, fogX, 0);
		document.getElementById('primaryCanvas').getContext('2d').drawImage(starFog, fogX_right, 0);
		//document.getElementById('primaryCanvas').getContext('2d').drawImage(cloudImg, fogX, 0);
		//document.getElementById('primaryCanvas').getContext('2d').drawImage(cloudImg, fogX_right, 0);
		
		//document.getElementById('primaryCanvas').getContext('2d').drawImage(cloudImg, 0, 0);
		
		
		enginesOn = 0.5;
				
		
		if(starTimer == 3)
		{
			starTimer = 0;
			fogX = fogX - (0.3*enginesOn)-0.3 -1;
			fogX_right = fogX_right - (0.3*enginesOn)-0.3 -1; //-2
			
			if(fogX<=-1920)
				fogX=1920;
				
			if(fogX_right<=-1920)
			fogX_right=1920;
		
		}
		
		if(starTimer == 1)
		{
			/*
			starTimer = 0;
			starX_right = starX_right - (0.3*enginesOn);// -0.3;
			starX = starX - (0.3*enginesOn);//-0.3;
			
			if(starX<=-1920)
				starX=1920;
				
			if(starX_right<=-1920)
				starX_right=1920;
			*/			
			
		}
		starTimer = starTimer +1;
	
	}
	
	function preShake() 
	{
	  context.save();
	  var dx = Math.random()*10;
	  var dy = Math.random()*10;
	  context.translate(dx, dy);  
	}
	
	function postShake() 
	{
		context.restore();
	}
	
	function getTileY(givenY)
	{
		var fmlY = tileSize + Math.floor(givenY - yTravelled);
		if(fmlY < 0)
			fmlY = fmlY + boundingHeight+64;
		return(Math.floor(fmlY/tileSize));
	}
	
	function drawCamera()
	{
		
		//var canvas = document.getElementById("primaryCanvas");
		//var context = document.getElementById("primaryCanvas").getContext('2d');
		context.clearRect(0, 0, canvas.width, canvas.height);
		
		
		//old_drawStars();
		drawStars();
		
		
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(explosionSheet, 0, 0);
	//	document.getElementById("primaryCanvas").getContext('2d').drawImage(nebulaA, -150, -150);
		
		
		//document.getElementById("primaryCanvas").getContext('2d').drawImage(ninja, nX, nY);
		
		
		if(gameStarted)
		{
		
			//document.getElementById("primaryCanvas").getContext('2d').drawImage(dirt, 50, 50);
		
			for (x = 0; x < mapWidth; x++)
			{
				for (y = 0; y < mapHeight; y++)
				{
					/*
					if(map[x][y].f=="a")
						context.drawImage(dirt, x*tileSize, y*tileSize)
					else if(map[x][y].f=="b")
						context.drawImage(dirtB, x*tileSize, y*tileSize)
					else if(map[x][y].f=="c")
						context.drawImage(dirtC, x*tileSize, y*tileSize)
					else if(map[x][y].f=="d")
						context.drawImage(heartFull, x*tileSize, y*tileSize);
					*/
					if(map[x][y].f=="a")
						context.drawImage(dirt, map[x][y].x, map[x][y].y)
					else if(map[x][y].f=="b")
						context.drawImage(dirtB, map[x][y].x, map[x][y].y) //stone
					else if(map[x][y].f=="c")
						context.drawImage(dirtC, map[x][y].x, map[x][y].y)
					else if(map[x][y].f=="d")
						context.drawImage(stone, map[x][y].x, map[x][y].y);	
					
					
					//scrolling text check
					/*
					if(x==1)
					{
						context.fillStyle = 'white';
						var maxWidth = 500;//400
						var lineHeight = 25;
						wrapText(context, ""+y+","+map[x][y].y, map[x][y].x, map[x][y].y, maxWidth, lineHeight);
					}
					*/
				
					//need to add up/down 
					//left right here 
					//also think about directions of things, we have some issues 
					//not sure how approaching rails from diff directions changes things 
					if((map[x][y].b=="up") || (map[x][y].b=="down"))
						context.drawImage(rail, map[x][y].x, map[x][y].y)
					else if((map[x][y].b=="left") || (map[x][y].b=="right"))
						context.drawImage(railH, map[x][y].x, map[x][y].y)
					else if(map[x][y].b=="railH")
						context.drawImage(railH, map[x][y].x, map[x][y].y)
					else if(map[x][y].b=="topleft")
						context.drawImage(railTopLeft, map[x][y].x, map[x][y].y)	
					else if(map[x][y].b=="topright")
						context.drawImage(railTopRight, map[x][y].x, map[x][y].y)
					else if(map[x][y].b=="bottomleft")
						context.drawImage(railBottomLeft, map[x][y].x, map[x][y].y)
					else if(map[x][y].b=="bottomright")
						context.drawImage(railBottomRight, map[x][y].x, map[x][y].y);
					//else
					///	context.drawImage(dirtB, x*tileSize, y*tileSize);
				}
			}
			
			trainX = lastRailX*tileSize;
			trainY = boundingHeight-400;
			
			/*			
			drawR(trainTurret,trainX+120,trainY+75,45,"primaryCanvas")
			*/
			
			for (var i = 0; i < bloodX.length; i++)
			{
				context.drawImage(bloodDecal[bloodID[i]], bloodX[i], bloodY[i]);
			}
			
			for (var i = 0; i < ship.length; i++)
			{
				if(ship[i].type == "fan")
					drawR(ship[i].image,ship[i].x,ship[i].y,0,"primaryCanvas")
				else
					drawR(ship[i].image,ship[i].x,ship[i].y,ship[i].rot+90,"primaryCanvas");
			}
			
			for (var i = 0; i < comp.length; i++)
			{
				drawR(comp[i].image,comp[i].x,comp[i].y,comp[i].rot+90,"primaryCanvas")
			}
			
			//context.drawImage(greenSquare, comp[0].x, comp[0].y);
			
			
		}
		//draw explosions
		for (var i = exp.length-1; i >= 0; i--)
		{
			document.getElementById(exp[i].canvas).getContext('2d').drawImage(explosionSheet, 50*exp[i].frame, 0, 50, 50, exp[i].x-35, exp[i].y-35, 50, 50);
			
			exp[i].frame = exp[i].frame + 1;
			if(exp[i].frame==11)
			{
				exp.splice(i,1);
			}
		}
		
		exp_update();
		
		sCurr = "SCORE: " + playerScore;
		var maxWidth = 500;//400
		var lineHeight = 25;
		
		//context.font = '16pt Calibri';
		//context.fillStyle = 'white';
		
		//context.font = "30px Arial";
		context.font = '16pt Calibri';
		if(screenShakeDuration>0)
			context.fillStyle = 'red';
		else
			context.fillStyle = 'darkred';
		
		if(gameStarted)
		{
		
			//wrapText(context, sCurr, (boundingWidth/2)-30, boundingHeight-50, maxWidth, lineHeight);
			context.fillStyle = 'white';
			
			//wrapText(context, "TIMER: " +globalTimer, (boundingWidth/2)-30, 25, maxWidth, lineHeight);
			//wrapText(context, "ENEMIES LEFT: " +enemiesLeft, (boundingWidth/2)-80, 25, maxWidth, lineHeight);
			
			distanceTravelled = distanceTravelled + 0.2;
			
			wrapText(context, "DISTANCE TRAVELLED: " +Math.floor(distanceTravelled) +"m", (boundingWidth/2)-150, 25, maxWidth, lineHeight);
			
			
			//maxWidth = 300;
			//wrapText(context, touchText, 25, 50, maxWidth, lineHeight);
		
			//playerHealth = 10;
		
			//left and right panels and rail icons
			//document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, boundingX+30, boundingHeight-80-48);
			//document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[0], boundingX+30+8, boundingHeight-80-48+9);
			//document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, boundingWidth-100, boundingHeight-80-48);
			//document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[1], boundingWidth-100+8, boundingHeight-80-48+9);
			
			//panelX[0] = boundingX+30;
			//panelY[0] = boundingHeight-80-48;
			//panelX[1] = boundingWidth-100;
			//panelY[1] = boundingHeight-80-48;
			
			//left and right panels and rail icons
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[0], panelY[0]);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[0], panelX[0]+8, panelY[0]+9);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[1], panelY[1]);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(railRep[1],panelX[1]+8, panelY[1]+9);
					
			//left and right panels for keys 
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[0], boundingHeight-80);
			document.getElementById("primaryCanvas").getContext('2d').drawImage(panel, panelX[1], boundingHeight-80);
			
			
			
			
			context.font = '24pt Calibri';
			context.fillStyle = 'white';
			adjustX = 13;
			adjustY = 33;
			wrapText(context, keyArray[0][0], boundingX+30+adjustX, boundingHeight-80+adjustY, maxWidth, lineHeight);
			wrapText(context, keyArray[1][0], boundingWidth-100+adjustX, boundingHeight-80+adjustY, maxWidth, lineHeight);
						
			/*
			//reports on some of the tile/track positioning
			x = 1;
			for (y = 0; y < mapHeight; y++)
			{
				context.fillStyle = 'white';
				var maxWidth = 500;//400
				var lineHeight = 25;
				wrapText(context, ""+y+";"+Math.floor(map[x][y].y), map[x][y].x, map[x][y].y, maxWidth, lineHeight);
			}
						
			maxWidth = 1000;
			wrapText(context, "The car is at "+comp[0].y + " pixels", 300, 300, maxWidth, lineHeight);
			wrapText(context, "Objectively, the the tile would be: "+comp[0].y + "/ tileSize, so " +Math.floor(comp[0].y/tileSize), 300, 330, maxWidth, lineHeight);
			wrapText(context, "car y - distanceShifterd = " +Math.floor(comp[0].y - yTravelled), 300, 365, maxWidth, lineHeight);
			wrapText(context, "The tiles have been shifted "+ Math.floor(yTravelled) + " pixels from their original start", 300, 400, maxWidth, lineHeight);
			wrapText(context, "tile 8 y: " +Math.floor(map[0][8].y) + " vs " +Math.floor(comp[0].y + yTravelled), 300, 425, maxWidth, lineHeight);
			
			//player.dy = -0.5; //0/01
			
			var crazyY = Math.floor(comp[0].y + yTravelled);
			if(crazyY > boundingHeight+32)
				crazyY = crazyY - (boundingHeight+64);
			
			wrapText(context, "tile 8 y: " +Math.floor(map[0][8].y) + " vs " +crazyY, 300, 455, maxWidth, lineHeight);
			wrapText(context, "The train might be on tile: " + getTileY(comp[0].y), 300, 510, maxWidth, lineHeight);
			wrapText(context, "Map " + Math.floor(comp[0].x/tileSize) + ";" + getTileY(comp[0].y) + " is " + map[Math.floor(comp[0].x/tileSize)][getTileY(comp[0].y)].b, 300, 540, maxWidth, lineHeight);
			*/
			
			if(map[Math.floor(comp[0].x/tileSize)][getTileY(comp[0].y)].b==".")
			{
				//train not on a rail
				//playerHealth--;
				
				grindTimer++;
				if(grindTimer>3)
				{
					grindTimer = 0;
					
					explodeSomething(comp[0].x-16,comp[0].y+16,"spark");
					explodeSomething(comp[0].x+16,comp[0].y+16,"spark");
					playerHealth--;
					if(playerHealth <= 0)
					{
						showDefeat();
					}
				}
				
				
				
			}
			
		
			startingX = (playerHealth*16)-16;
			for (var i = 0; i < playerHealth; i++)
			{
				document.getElementById("primaryCanvas").getContext('2d').drawImage(heartFull, startingX+(boundingWidth/2)-(32*i), boundingHeight-40);
			}
		
		}
		
		
		
	}
	
	function rotateA2B(a,b)
	{
		x2 = b.x;
		y2 = b.y;
		x1 = a.x;
		y1 = a.y;
		
		var deltaX = x2 - x1;
		var deltaY = y2 - y1;
		var rad = Math.atan2(deltaY, deltaX);
		var deg = rad * (180 / Math.PI)
		
		a.rot = deg;
		
	}
	
	function rotateShipToMouseXY(pShip)
	{
		//rotate player ship to face mouse cursor
		x2 = adjustedMouseX;
		y2 = adjustedMouseY;
		x1 = pShip.x;
		y1 = pShip.y;
		
		var deltaX = x2 - x1;
		var deltaY = y2 - y1;
		var rad = Math.atan2(deltaY, deltaX);
		var deg = rad * (180 / Math.PI)
		
		pShip.rot = deg;
	}
	
	function changeRotation(rot,change)
	{
		extraRot = 0;
		rot=rot+change;
		if(rot>360)
		{
			extraRot = rot-360;
			rot = 0+extraRot;
		}
		else if(rot<0)
		{
			extraRot = rot*-1;
			rot = 360 - extraRot;
		}
		return(rot);
	}
	
	function toRadians (angle) 
	{
		return angle * (Math.PI / 180);
	}
	
	function drawR(image,x,y,rot,c)
	{
		//if(withinBounds(x,y))
	//	if(withinBoundsWH(x,y,image.width,image.height))
		{
			var canvas = document.getElementById(c);
			var context = document.getElementById(c).getContext('2d');
			
			//var x = 748;//canvas.width / 2;
			//var y = 567;//canvas.height / 2;
			var width = image.width;
			var height = image.height;

			angleInRadians = toRadians(rot);
			
			context.translate(x, y);
			context.rotate(angleInRadians);
			context.drawImage(image, -width / 2, -height / 2, width, height);
			context.rotate(-angleInRadians);
			context.translate(-x, -y);
		}
	}
	
	function handleTrainMovement()
	{
		
		yTravelled = yTravelled - player.dy;
		if(yTravelled > boundingHeight+32)
			yTravelled = -31;
		
		for (var i = bloodY.length-1; i >= 0; i--)
		{
			bloodY[i] = bloodY[i] - player.dy;
			if(bloodY[i] > boundingHeight+32)
			{
				bloodX.splice(i,1);
				bloodY.splice(i,1);
				bloodID.splice(i,1);
			}
		}
		
		for (x = 0; x < mapWidth; x++)
		{
			for (y = 0; y < mapHeight; y++)
			{
				map[x][y].y = map[x][y].y - player.dy;
				if(map[x][y].y > boundingHeight+32) //64
				{
					map[x][y].y = -31;//0 //-31
					
					
					map[x][y].b = ".";
					var r = Math.floor(Math.random()*3); //4
					if(r==0)
						map[x][y].f = "a"
					else if(r==1)
						map[x][y].f = "b"
					else if(r==2)
						map[x][y].f = "c"
					else if(r==3)
						map[x][y].f = "d";
				
				}
			}
		}
		
		
		
	}
	
	function handleShipMovement()
	{
		//for (var i = ship.length-1; i >= 0; i--)
		for (var i = 0; i < ship.length; i++)
		{
			
			//////////////////
			//handle turning 
			//////////////////
			
			if(waveMode)
			{
				//don't rotate the ships
				//ship[i].rot = changeRotation(ship[i].rot,ship[i].turningSpeed);
			}
			else
			{
			
				x2 = ship[i].targetX;//player.x;
				y2 = ship[i].targetY;//player.y;
				x1 = ship[i].x;
				y1 = ship[i].y;
				
				var deltaX = x2 - x1;
				var deltaY = y2 - y1;
				var rad = Math.atan2(deltaY, deltaX);
				var deg = rad * (180 / Math.PI)
				
				idealRotation = deg;
				if(deg < 0)
					idealRotation = 360+deg;
				
				idealRotation = Math.floor(idealRotation);
				var turning = true;
				var leftTurnRot = Math.floor(ship[i].rot);
				var leftTurn = 0;
				while(turning)
				{
					leftTurn++;
					
					leftTurnRot = changeRotation(leftTurnRot,-1);
					
					if(leftTurnRot==idealRotation)
						turning = false;
									
					if(leftTurn>370)
					{
						//alert(idealRotation + ";" + leftTurn + ";" + rightTurn);
						turning = false;
					}
				}
				
				var turning = true;
				var rightTurnRot = Math.floor(ship[i].rot);
				var rightTurn = 0;
				while(turning)
				{
					rightTurn++;
					
					rightTurnRot = changeRotation(rightTurnRot,1);
				
					if(rightTurnRot==idealRotation)
						turning = false;

					if(rightTurn>370)
					{
						//alert(idealRotation + ";" + leftTurn + ";" + rightTurn);
						turning = false;
					}
				}
				
				if(leftTurn<rightTurn)
					ship[i].rot = changeRotation(ship[i].rot,-ship[i].turningSpeed)
				else
					ship[i].rot = changeRotation(ship[i].rot,ship[i].turningSpeed)
				
					
				if(i==0)
				{
					//rotDetail = xDiff + ";" + yDiff;
					//rotDetail = Math.floor(ship[i].rot)+ "; " + Math.floor(idealRotation) + "; " + Math.floor(dif);
					//rotDetail = idealRotation + ";" + leftTurn + ";" + rightTurn;
				}
			
			}
		
		
		
		
			//////////////////
			//handle thrust 
			//////////////////
			//thrust
			if(true)
			{
				ship[i].ax = Math.cos(ship[i].rot*Math.PI/180)*ship[i].accelerationPower;
				ship[i].ay = Math.sin(ship[i].rot*Math.PI/180)*ship[i].accelerationPower;
			}
			else
			{
				//no acceleration is being applied, so cancel acceleration
				ship[i].ax = 0;
				ship[i].ay = 0;
			}
			
			
			//update velocity
			ship[i].dx += ship[i].ax;
			ship[i].dy += ship[i].ay;
			
			var tempDX = ship[i].dx;
			var tempDY = ship[i].dy;
			
			tempSpeed = Math.sqrt(tempDX * tempDX + tempDY * tempDY);
			if (tempSpeed > ship[i].maxSpeed) 
			{
				//the resulting speed is always <= maxspeed (normed to that)
				//ship[i].dy *= ship[i].maxSpeed/tempSpeed;
				//ship[i].dx *= ship[i].maxSpeed/tempSpeed;
				
				ship[i].dy /= tempSpeed/ship[i].maxSpeed;
				ship[i].dx /= tempSpeed/ship[i].maxSpeed;
			}
			
			
			//decrease speed due to friction/brakes
			if (false)
			{	
				
				ship[i].dy *= playerFriction;
				if(((ship[i].dy > 0) && (ship[i].dy < 1)) || ((ship[i].dy < 0) && (ship[i].dy > -1)))
					ship[i].dy = 0;
				ship[i].dx *= playerFriction;
				if(((ship[i].dx > 0) && (ship[i].dx < 1)) || ((ship[i].dx < 0) && (ship[i].dx > -1)))
					ship[i].dx = 0;
			}
					
			
			//update position
			ship[i].x = ship[i].x + ship[i].dx;
			ship[i].y = ship[i].y + ship[i].dy;
			
			
			if(ship[i].y > boundingHeight)
			{
				respawnShip(i);
				
				//screenShakeDuration = 15;
				//playerHealth--;
				//if(playerHealth <= 0)
				//{
				//	showDefeat();
				//}
				//else
				//{
				//	ship[i].health = 5000;
				//}
			}
			
			if(ship[i].x > boundingWidth)
				ship[i].dx *= -1;
			
			if(ship[i].x < 0)
				ship[i].dx *= -1;
			
			//out of map bounds 
			/*
			if(ship[i].x > 1900)
				ship[i].dx *= -1;
			
			if(ship[i].y > 900)
				ship[i].dy *= -1;
			
			if(ship[i].x < 0)
				ship[i].dx *= -1;
			
			if(ship[i].y < 0)
				ship[i].dy *= -1;
			*/
		
			
		
		}
	}
	
	function handleGameLogic()
	{
	
		for (var i = ship.length-1; i >= 0; i--)
		{
			
			if(waveMode)
			{
				if(ship[i].health <= 0)
				{
					
					playerScore = playerScore + 1;
					screenShakeDuration = 15;
							
					exp[exp.length] = new explosion(ship[i].x+16,ship[i].y+16,"exp");
					
					
					enemiesLeft--;
					
					
					ship.splice(i,1);
					
					if(enemiesLeft<=0)
						showWin();
					
					
						
					
				}
				else if((ship[i].health == 5000) && (playerHealth > 0))
				{
					enemiesLeft--;
					ship.splice(i,1);
					if(enemiesLeft<=0)
						showWin();
				}

			}
			else 
			{
				
				if(getDist(ship[i].x+16,ship[i].y+16,comp[0].x,comp[0].y)<32)
				{
					ship[i].health = -100;
					
					playerHealth--;
					if(playerHealth <= 0)
					{
						showDefeat();
					}
					
				}
				
				if(ship[i].health <= 0)
				{
					
					playerScore = playerScore + 1;
					screenShakeDuration = 15;
							
					exp[exp.length] = new explosion(ship[i].x+16,ship[i].y+16,"exp");
					
					if(ship[i].type=="boss")
						ship[i].health = 10
					else
						ship[i].health = 1;
					
					//if the "ship" is a flesh and blood fan, pop them
					//and leave a nice blood decal on the ground
					if(ship[i].type=="fan")
					{
						bloodX[bloodX.length] = ship[i].x-16;
						bloodY[bloodY.length] = ship[i].y-16;
						bloodID[bloodID.length] = Math.floor(Math.random() * bloodDecal.length);
					}
					
					respawnShip(i);
					
					
					enemiesLeft--;
					
					if(ship.length > enemiesLeft)
						ship.splice(i,1);
					
					if(enemiesLeft<=0)
						showWin();
					
					
						
					
				}
				else if((ship[i].health == 5000) && (playerHealth > 0))
				{
					enemiesLeft--;
					
					if(ship[i].type=="boss")
						ship[i].health = 10
					else
						ship[i].health = 1;
						
					if(ship.length > enemiesLeft)
						ship.splice(i,1);
					if(enemiesLeft<=0)
						showWin();
				}
			
			}
		}
	
	}
	
	function update()
	{
		
		//drawCamera();
		
		if(gameStarted)
		{
			handleShipMovement();
			handleTrainMovement();
		}
		
		if(screenShakeDuration>0)
		{
			screenShakeDuration--;
			preShake();
			drawCamera();
			postShake();
		}
		else
			drawCamera();
		
		handleGameLogic();
		
		requestAnimationFrame(update);
	}
	
	function timedInterval()
	{
		
		if(document.getElementById("winScreen").style.display == "block")
		{
		
			if(document.getElementById("titleText").style.color == "orange")
				document.getElementById("titleText").style.color = "gold"
			else if (document.getElementById("titleText").style.color == "gold")
				document.getElementById("titleText").style.color = "lime"
			else if (document.getElementById("titleText").style.color == "lime")
				document.getElementById("titleText").style.color = "aqua"
			else if (document.getElementById("titleText").style.color == "aqua")
				document.getElementById("titleText").style.color = "violet"	
			else if (document.getElementById("titleText").style.color == "violet")
				document.getElementById("titleText").style.color = "red"
			else if (document.getElementById("titleText").style.color == "red")
				document.getElementById("titleText").style.color = "orange";
		}
		
		else if(document.getElementById("loseScreen").style.display == "block")
		{
			document.getElementById("titleText").style.color = "red";
			explodeSomething(30+ Math.floor(Math.random() * (boundingWidth-80))+boundingX,50+Math.floor(Math.random() * (boundingHeight-140))+boundingY,"boom");
		}
		
		if(gameStarted)
		{
			
			//give a slight delay after killing the last enemy of the wave 
			//so we can see their death throes before showing the win screen
			if(finalCountdown != 5000)
				finalCountdown--;
			if(finalCountdown <=0)
				showActualWin();
			
			globalTimer--;
			
			if(waveMode)
			{
				if((enemiesLeft > ship.length) && (playerLevel >= 3))
				{
					if(chainActive==false)
					{
						chainActive = true;
						chainLength = 3;
						chainX =  30+ Math.floor(Math.random() * (boundingWidth-80))+boundingX;
						
					}
					
					if(chainActive)
					{
						chainLength--;
						if(chainLength==0)
							chainActive = false;
						
						if(playerLevel>=6)
							ship[ship.length] = new entity(0,0,"runner")
						else
							ship[ship.length] = new entity(0,0,"grunt");
						respawnShip(ship.length-1);
						
						ship[ship.length-1].rot = 90; //270
						ship[ship.length-1].x = chainX;
						ship[ship.length-1].y = 50;
						ship[ship.length-1].targetX = chainX;
						ship[ship.length-1].targetY = boundingHeight;
					}
					
				}
			}
			
			if(globalTimer < 0)
			{
				//doNothing()
				//showWin();
				
				
			}
		}
	}
	
	function TryPlay(s)
	{

		/*if ((s == "track1") || (s == "track2") || (s == "track3") || (s == "track4"))
		{

			if (musicOn)
				document.getElementById(s).play();

			currentTrack = s;
		}

		else */if (soundOn)
		{
			//if you want the same sound to reset it's look so it always plays, uncomment
			//document.getElementById(s).currentTime = 0;
			document.getElementById(s).play();
			
		}
	}
	
	window.addEventListener("load", function()
	{
		update();
	});
	
	window.setInterval(timedInterval, 50000 / 60);
	
	</script>
	
	<script src="rot.js"></script>
	
	<script type="text/javascript" src="core.js"></script>
	<script type="text/javascript" src="explosion_html5.js"></script>
	
	<!--
	<audio id="mayhem" preload="auto">
        <source src="audio/8-Bit-Mayhem.mp3" type="audio/mp3">
    </audio>
	-->
</body>

</html>
